<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="http://learnopengl.com 系列教程的简体中文翻译">
        
        <link rel="canonical" href="https://learnopengl-cn.github.io/07%20PBR/01%20Theory/">
        <link rel="shortcut icon" href="../../img/favicon.ico">

	<title>理论 - LearnOpenGL CN</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="../../css/style.css" rel="stylesheet">
        <link href="../../css/admonition_fix.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
          ga('create', 'UA-80323542-1', 'auto');
          ga('send', 'pageview');
        </script>
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">LearnOpenGL CN</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="../..">主页</a>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">目录 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
<li >
    <a href="../../intro/">简介</a>
</li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">入门</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../01%20Getting%20started/01%20OpenGL/">OpenGL</a>
</li>

        
            
<li >
    <a href="../../01%20Getting%20started/02%20Creating%20a%20window/">创建窗口</a>
</li>

        
            
<li >
    <a href="../../01%20Getting%20started/03%20Hello%20Window/">你好，窗口</a>
</li>

        
            
<li >
    <a href="../../01%20Getting%20started/04%20Hello%20Triangle/">你好，三角形</a>
</li>

        
            
<li >
    <a href="../../01%20Getting%20started/05%20Shaders/">着色器</a>
</li>

        
            
<li >
    <a href="../../01%20Getting%20started/06%20Textures/">纹理</a>
</li>

        
            
<li >
    <a href="../../01%20Getting%20started/07%20Transformations/">变换</a>
</li>

        
            
<li >
    <a href="../../01%20Getting%20started/08%20Coordinate%20Systems/">坐标系统</a>
</li>

        
            
<li >
    <a href="../../01%20Getting%20started/09%20Camera/">摄像机</a>
</li>

        
            
<li >
    <a href="../../01%20Getting%20started/10%20Review/">复习</a>
</li>

        
    </ul>
  </li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">光照</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../02%20Lighting/01%20Colors/">颜色</a>
</li>

        
            
<li >
    <a href="../../02%20Lighting/02%20Basic%20Lighting/">基础光照</a>
</li>

        
            
<li >
    <a href="../../02%20Lighting/03%20Materials/">材质</a>
</li>

        
            
<li >
    <a href="../../02%20Lighting/04%20Lighting%20maps/">光照贴图</a>
</li>

        
            
<li >
    <a href="../../02%20Lighting/05%20Light%20casters/">投光物</a>
</li>

        
            
<li >
    <a href="../../02%20Lighting/06%20Multiple%20lights/">多光源</a>
</li>

        
            
<li >
    <a href="../../02%20Lighting/07%20Review/">复习</a>
</li>

        
    </ul>
  </li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">模型加载</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../03%20Model%20Loading/01%20Assimp/">Assimp</a>
</li>

        
            
<li >
    <a href="../../03%20Model%20Loading/02%20Mesh/">网格</a>
</li>

        
            
<li >
    <a href="../../03%20Model%20Loading/03%20Model/">模型</a>
</li>

        
    </ul>
  </li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">高级OpenGL</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../04%20Advanced%20OpenGL/01%20Depth%20testing/">深度测试</a>
</li>

        
            
<li >
    <a href="../../04%20Advanced%20OpenGL/02%20Stencil%20testing/">模板测试</a>
</li>

        
            
<li >
    <a href="../../04%20Advanced%20OpenGL/03%20Blending/">混合</a>
</li>

        
            
<li >
    <a href="../../04%20Advanced%20OpenGL/04%20Face%20culling/">面剔除</a>
</li>

        
            
<li >
    <a href="../../04%20Advanced%20OpenGL/05%20Framebuffers/">帧缓冲</a>
</li>

        
            
<li >
    <a href="../../04%20Advanced%20OpenGL/06%20Cubemaps/">立方体贴图</a>
</li>

        
            
<li >
    <a href="../../04%20Advanced%20OpenGL/07%20Advanced%20Data/">高级数据</a>
</li>

        
            
<li >
    <a href="../../04%20Advanced%20OpenGL/08%20Advanced%20GLSL/">高级GLSL</a>
</li>

        
            
<li >
    <a href="../../04%20Advanced%20OpenGL/09%20Geometry%20Shader/">几何着色器</a>
</li>

        
            
<li >
    <a href="../../04%20Advanced%20OpenGL/10%20Instancing/">实例化</a>
</li>

        
            
<li >
    <a href="../../04%20Advanced%20OpenGL/11%20Anti%20Aliasing/">抗锯齿</a>
</li>

        
    </ul>
  </li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">高级光照</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../05%20Advanced%20Lighting/01%20Advanced%20Lighting/">高级光照</a>
</li>

        
            
<li >
    <a href="../../05%20Advanced%20Lighting/02%20Gamma%20Correction/">Gamma校正</a>
</li>

        
            
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">阴影</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../05%20Advanced%20Lighting/03%20Shadows/01%20Shadow%20Mapping/">阴影映射</a>
</li>

        
            
<li >
    <a href="../../05%20Advanced%20Lighting/03%20Shadows/02%20Point%20Shadows/">点阴影</a>
</li>

        
            
<li >
    <a href="../../05%20Advanced%20Lighting/03%20Shadows/03%20CSM/">CSM</a>
</li>

        
    </ul>
  </li>

        
            
<li >
    <a href="../../05%20Advanced%20Lighting/04%20Normal%20Mapping/">法线贴图</a>
</li>

        
            
<li >
    <a href="../../05%20Advanced%20Lighting/05%20Parallax%20Mapping/">视差贴图</a>
</li>

        
            
<li >
    <a href="../../05%20Advanced%20Lighting/06%20HDR/">HDR</a>
</li>

        
            
<li >
    <a href="../../05%20Advanced%20Lighting/07%20Bloom/">泛光</a>
</li>

        
            
<li >
    <a href="../../05%20Advanced%20Lighting/08%20Deferred%20Shading/">延迟着色法</a>
</li>

        
            
<li >
    <a href="../../05%20Advanced%20Lighting/09%20SSAO/">SSAO</a>
</li>

        
    </ul>
  </li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">PBR</a>
    <ul class="dropdown-menu">
        
            
<li class="active">
    <a href="./">理论</a>
</li>

        
            
<li >
    <a href="../02%20Lighting/">光照</a>
</li>

        
            
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">IBL</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../03%20IBL/01%20Diffuse%20irradiance/">漫反射辐照</a>
</li>

        
            
<li >
    <a href="../03%20IBL/02%20Specular%20IBL/">镜面IBL</a>
</li>

        
    </ul>
  </li>

        
    </ul>
  </li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">实战</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../06%20In%20Practice/01%20Debugging/">调试</a>
</li>

        
            
<li >
    <a href="../../06%20In%20Practice/02%20Text%20Rendering/">文本渲染</a>
</li>

        
            
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">2D游戏</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../06%20In%20Practice/2D-Game/01%20Breakout/">Breakout</a>
</li>

        
            
<li >
    <a href="../../06%20In%20Practice/2D-Game/02%20Setting%20up/">准备工作</a>
</li>

        
            
<li >
    <a href="../../06%20In%20Practice/2D-Game/03%20Rendering%20Sprites/">渲染精灵</a>
</li>

        
            
<li >
    <a href="../../06%20In%20Practice/2D-Game/04%20Levels/">关卡</a>
</li>

        
            
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">碰撞</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../06%20In%20Practice/2D-Game/05%20Collisions/01%20Ball/">球</a>
</li>

        
            
<li >
    <a href="../../06%20In%20Practice/2D-Game/05%20Collisions/02%20Collision%20detection/">碰撞检测</a>
</li>

        
            
<li >
    <a href="../../06%20In%20Practice/2D-Game/05%20Collisions/03%20Collision%20resolution/">碰撞处理</a>
</li>

        
    </ul>
  </li>

        
            
<li >
    <a href="../../06%20In%20Practice/2D-Game/06%20Particles/">粒子</a>
</li>

        
            
<li >
    <a href="../../06%20In%20Practice/2D-Game/07%20Postprocessing/">后期处理</a>
</li>

        
            
<li >
    <a href="../../06%20In%20Practice/2D-Game/08%20Powerups/">道具</a>
</li>

        
            
<li >
    <a href="../../06%20In%20Practice/2D-Game/09%20Audio/">音效</a>
</li>

        
            
<li >
    <a href="../../06%20In%20Practice/2D-Game/10%20Render%20Text/">渲染文本</a>
</li>

        
            
<li >
    <a href="../../06%20In%20Practice/2D-Game/11%20Final%20thoughts/">结语</a>
</li>

        
    </ul>
  </li>

        
    </ul>
  </li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">Guest Articles</a>
    <ul class="dropdown-menu">
        
            
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">2020</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../08%20Guest%20Articles/2020/01%20Skeletal%20Animation/">骨骼动画</a>
</li>

        
    </ul>
  </li>

        
            
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">2022</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../08%20Guest%20Articles/2022/03%20Area%20Lights/">区域光</a>
</li>

        
    </ul>
  </li>

        
    </ul>
  </li>

                    
                        
<li >
    <a href="../../legacy/">历史存档</a>
</li>

                    
                    </ul>
                </li>
            
            
            
                <li >
                    <a href="../../code_repo/">代码仓库</a>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> 搜索
                    </a>
                </li>
                <li >
                    <a rel="next" href="../../05%20Advanced%20Lighting/09%20SSAO/">
                        <i class="fa fa-arrow-left"></i> 上一节
                    </a>
                </li>
                <li >
                    <a rel="prev" href="../02%20Lighting/">
                        下一节 <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
                <li>
                    <a href="https://github.com/LearnOpenGL-CN/LearnOpenGL-CN">
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
                <li>
                    <a href="https://www.paypal.me/learnopengl/">
                            <img class="paypal" src="/img/paypal_logo.png" alt="">
                        支持原作者
                    </a>
                </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#_1">理论</a></li>
        
            <li><a href="#_2">微平面模型</a></li>
        
            <li><a href="#_3">能量守恒</a></li>
        
            <li><a href="#_4">反射率方程</a></li>
        
            <li><a href="#brdf">BRDF</a></li>
        
            <li><a href="#pbr">编写PBR材质</a></li>
        
            <li><a href="#_8">延伸阅读</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h1 id="_1">理论</h1>
<table>
<thead>
<tr>
<th>原文</th>
<th><a href="https://learnopengl.com/#!PBR/Theory">Theory</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>作者</td>
<td>JoeyDeVries</td>
</tr>
<tr>
<td>翻译</td>
<td><a href="https://github.com/JiangMuWen">J.moons</a></td>
</tr>
<tr>
<td>校对</td>
<td>Krasjet, JeremyYvv</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>本节暂未进行完全的重写，错误可能会很多。如果可能的话，请对照原文进行阅读。如果有报告本节的错误，将会延迟至重写之后进行处理。</p>
</div>
<p>PBR，或者用更通俗一些的称呼是指<def>基于物理的渲染</def>(Physically Based Rendering)，它指的是一些在不同程度上都基于与现实世界的物理原理更相符的基本理论所构成的渲染技术的集合。正因为基于物理的渲染目的便是为了使用一种更符合物理学规律的方式来模拟光线，因此这种渲染方式与我们原来的Phong或者Blinn-Phong光照算法相比总体上看起来要更真实一些。除了看起来更好些以外，由于它与物理性质非常接近，因此我们（尤其是美术师们）可以直接以物理参数为依据来编写表面材质，而不必依靠粗劣的修改与调整来让光照效果看上去正常。使用基于物理参数的方法来编写材质还有一个更大的好处，就是不论光照条件如何，这些材质看上去都会是正确的，而在非PBR的渲染管线当中有些东西就不会那么真实了。</p>
<p>虽然如此，基于物理的渲染仍然只是对基于物理原理的现实世界的一种近似，这也就是为什么它被称为<strong>基于</strong>物理的着色(Physically based Shading) 而非物理着色(Physical Shading)的原因。判断一种PBR光照模型是否是基于物理的，必须满足以下三个条件（不用担心，我们很快就会了解它们的）：</p>
<ol>
<li>基于微平面(Microfacet)的表面模型。</li>
<li>能量守恒。</li>
<li>应用基于物理的BRDF。</li>
</ol>
<p>在这次的PBR系列教程之中，我们将会把重点放在最先由迪士尼(Disney)提出探讨并被Epic Games首先应用于实时渲染的PBR方案。他们基于<def>金属质地工作流</def>(Metallic Workflow)的方案有非常完备的文献记录，广泛应用于各种流行的引擎之中并且有着非常令人惊叹的视觉效果。完成这次的教程之后我们将会制作出类似于这样的一些东西：</p>
<p><img alt="" src="../../img/07/01/ibl_specular_result_textured.png" /></p>
<p>请注意这个系列的教程所探讨的内容属于相当高端的领域，因此要求读者对OpenGL和着色器光照有较好的理解。读者将会需要这些相关的知识：<a href="../../04%20Advanced%20OpenGL/05%20Framebuffers/">帧缓冲</a>，<a href="../../04%20Advanced%20OpenGL/06%20Cubemaps/">立方体贴图</a>，<a href="../../05%20Advanced%20Lighting/02%20Gamma%20Correction/">Gamma校正</a>，<a href="../../05%20Advanced%20Lighting/06%20HDR/">HDR</a>和<a href="../../05%20Advanced%20Lighting/04%20Normal%20Mapping/">法线贴图</a>。我们还会深入探讨一些高等数学的内容，我会尽我所能将相关的概念阐述清楚。</p>
<h2 id="_2">微平面模型</h2>
<p>所有的PBR技术都基于微平面理论。这项理论认为，达到微观尺度之后任何平面都可以用被称为<def>微平面</def>(Microfacets)的细小镜面来进行描绘。根据平面粗糙程度的不同，这些细小镜面的取向排列可以相当不一致：</p>
<p><img alt="" src="../../img/07/01/microfacets.png" /></p>
<p>产生的效果就是：一个平面越是粗糙，这个平面上的微平面的排列就越混乱。这些微小镜面这样无序取向排列的影响就是，当我们特指镜面光/镜面反射时，入射光线更趋向于向完全不同的方向<def>发散</def>(Scatter)开来，进而产生出分布范围更广泛的镜面反射。而与之相反的是，对于一个光滑的平面，光线大体上会更趋向于向同一个方向反射，造成更小更锐利的反射：</p>
<p><img alt="" src="../../img/07/01/microfacets_light_rays.png" /></p>
<p>在微观尺度下，没有任何平面是完全光滑的。然而由于这些微平面已经微小到无法逐像素地继续对其进行区分，因此我们假设一个<def>粗糙度</def>(Roughness)参数，然后用统计学的方法来估计微平面的粗糙程度。我们可以基于一个平面的粗糙度来计算出众多微平面中，朝向方向沿着某个向量<script type="math/tex">h</script>方向的比例。这个向量<script type="math/tex">h</script>便是位于光线向量<script type="math/tex">l</script>和视线向量<script type="math/tex">v</script>之间的<def>半程向量</def>(Halfway Vector)。我们曾经在之前的<a href="../../05%20Advanced%20Lighting/01%20Advanced%20Lighting/">高级光照</a>教程中谈到过中间向量，它的计算方法如下：</p>
<p>
<script type="math/tex; mode=display">
h = \frac{l + v}{\|l + v\|}
</script>
</p>
<p>微平面的朝向方向与半程向量的方向越是一致，镜面反射的效果就越是强烈越是锐利。通过使用一个介于0到1之间的粗糙度参数，我们就能概略地估算微平面的取向情况了：</p>
<p><img alt="" src="../../img/07/01/ndf.png" /></p>
<p>我们可以看到，较高的粗糙度显示出来的镜面反射的轮廓要更大一些。与之相反，较小的粗糙度显示出的镜面反射轮廓则更小更锐利。</p>
<h2 id="_3">能量守恒</h2>
<p>微平面近似法使用了这样一种形式的<def>能量守恒</def>(Energy Conservation)：出射光线的能量永远不能超过入射光线的能量（发光面除外）。如上图我们可以看到，随着粗糙度的上升，镜面反射区域会增加，但是镜面反射的亮度却会下降。如果每个像素的镜面反射强度都一样（不管反射轮廓的大小），那么粗糙的平面就会放射出过多的能量，而这样就违背了能量守恒定律。这也就是为什么正如我们看到的一样，光滑平面的镜面反射更强烈而粗糙平面的反射更昏暗。</p>
<p>为了遵守能量守恒定律，我们需要对漫反射光和镜面反射光做出明确的区分。当一束光线碰撞到一个表面的时候，它就会分离成一个<def>折射</def>部分和一个<def>反射</def>部分。反射部分就是会直接反射开而不进入平面的那部分光线，也就是我们所说的镜面光照。而折射部分就是余下的会进入表面并被吸收的那部分光线，也就是我们所说的漫反射光照。</p>
<p>这里还有一些细节需要处理，因为当光线接触到一个表面的时候折射光是不会立即就被吸收的。通过物理学我们可以得知，光线实际上可以被认为是一束没有耗尽就不停向前运动的能量，而光束是通过碰撞的方式来消耗能量。每一种材料都是由无数微小的粒子所组成，这些粒子都能如下图所示一样与光线发生碰撞。这些粒子在每次的碰撞中都可以吸收光线所携带的一部分或者是全部的能量而后转变成为热量。</p>
<p><img alt="" src="../../img/07/01/surface_reaction.png" /></p>
<p>一般来说，并非全部能量都会被吸收，而光线也会继续沿着（基本上）随机的方向<def>发散</def>，然后再和其他的粒子碰撞直至能量完全耗尽或者再次离开这个表面。而光线脱离物体表面后将会协同构成该表面的（漫反射）颜色。不过在基于物理的渲染之中我们进行了简化，假设对平面上的每一点所有的折射光都会被完全吸收而不会散开。而有一些被称为<def>次表面散射</def>(Subsurface Scattering)技术的着色器技术将这个问题考虑了进去，它们显著地提升了一些诸如皮肤，大理石或者蜡质这样材质的视觉效果，不过伴随而来的代价是性能的下降。</p>
<p>对于<def>金属</def>(Metallic)表面，当讨论到反射与折射的时候还有一个细节需要注意。金属表面对光的反应与非金属（也被称为<def>介电质</def>(Dielectrics)）表面相比是不同的。它们遵从的反射与折射原理是相同的，但是<strong>所有的</strong>折射光都会被直接吸收而不会散开，只留下反射光或者说镜面反射光。亦即是说，金属表面只会显示镜面反射颜色，而不会显示出漫反射颜色。由于金属与电介质之间存在这样明显的区别，因此它们两者在PBR渲染管线中被区别处理，而我们将在文章的后面进一步详细探讨这个问题。</p>
<p>反射光与折射光之间的这个区别使我们得到了另一条关于能量守恒的经验结论：反射光与折射光它们二者之间是<strong>互斥</strong>的关系。无论何种光线，其被材质表面所反射的能量将无法再被材质吸收。因此，诸如折射光这样的余下的进入表面之中的能量正好就是我们计算完反射之后余下的能量。</p>
<p>我们按照能量守恒的关系，首先计算镜面反射部分，它的值等于入射光线被反射的能量所占的百分比。然后折射光部分就可以直接由镜面反射部分计算得出：</p>
<pre><code class="language-c++">float kS = calculateSpecularComponent(...); // 反射/镜面 部分
float kD = 1.0 - ks;                        // 折射/漫反射 部分
</code></pre>
<p>这样我们就能在遵守能量守恒定律的前提下知道入射光线的反射部分与折射部分所占的总量了。按照这种方法折射/漫反射与反射/镜面反射所占的份额都不会超过1.0，如此就能保证它们的能量总和永远不会超过入射光线的能量。而这些都是我们在前面的光照教程中没有考虑的问题。</p>
<h2 id="_4">反射率方程</h2>
<p>在这里我们引入了一种被称为<a href="https://learnopengl.com/wiki-rendereuqation">渲染方程</a>(Render Equation)的东西。它是某些聪明绝顶的人所构想出来的一个精妙的方程式，是如今我们所拥有的用来模拟光的视觉效果最好的模型。基于物理的渲染所坚定遵循的是一种被称为<def>反射率方程</def>(The Reflectance Equation)的渲染方程的特化版本。要正确地理解PBR，很重要的一点就是要首先透彻地理解反射率方程：</p>
<p>
<script type="math/tex; mode=display">
L_o(p,\omega_o) = \int\limits_{\Omega} f_r(p,\omega_i,\omega_o) L_i(p,\omega_i) n \cdot \omega_i  d\omega_i
</script>
</p>
<p>反射率方程一开始可能会显得有些吓人，不过随着我们慢慢对其进行剖析，读者最终会逐渐理解它的。要正确地理解这个方程式，我们必须要稍微涉足一些<def>辐射度量学</def>(Radiometry)的内容。辐射度量学是一种用来度量电磁场辐射（包括可见光）的手段。有很多种辐射度量(radiometric quantities)可以用来测量曲面或者某个方向上的光，但是我们将只会讨论其中和反射率方程有关的一种。它被称为<def>辐射率</def>(Radiance)，在这里用<script type="math/tex">L</script>来表示。辐射率被用来量化来自单一方向上的光线的大小或者强度。由于辐射率是由许多物理变量集合而成的，一开始理解起来可能有些困难，因此我们首先关注一下这些物理量：</p>
<p><strong>辐射通量</strong>：辐射通量<script type="math/tex">\Phi</script>表示的是一个光源所输出的能量，以瓦特为单位。光是由多种不同波长的能量所集合而成的，而每种波长则与一种特定的（可见的）颜色相关。因此一个光源所放射出来的能量可以被视作这个光源包含的所有各种波长的一个函数。波长介于390nm到700nm（纳米）的光被认为是处于可见光光谱中，也就是说它们是人眼可见的波长。在下面你可以看到一幅图片，里面展示了日光中不同波长的光所具有的能量：</p>
<p><img alt="" src="../../img/07/01/daylight_spectral_distribution.png" /></p>
<p>辐射通量将会计算这个由不同波长构成的函数的总面积。直接将这种对不同波长的计量作为参数输入计算机图形有一些不切实际，因此我们通常不直接使用波长的强度而是使用三原色编码，也就是<strong>RGB</strong>（或者按通常的称呼：光色）来作为辐射通量表示的简化。这套编码确实会带来一些信息上的损失，但是这对于视觉效果上的影响基本可以忽略。</p>
<p><strong>立体角</strong>：立体角用<script type="math/tex">\omega</script>表示，它可以为我们描述投射到单位球体上的一个截面的大小或者面积。投射到这个单位球体上的截面的面积就被称为<def>立体角</def>(Solid Angle)，你可以把立体角想象成为一个带有体积的方向：</p>
<p><img alt="" src="../../img/07/01/solid_angle.png" /></p>
<p>可以把自己想象成为一个站在单位球面的中心的观察者，向着投影的方向看。这个投影轮廓的大小就是立体角。</p>
<p><strong>辐射强度</strong>：辐射强度(Radiant Intensity)表示的是在单位球面上，一个光源向每单位立体角所投送的辐射通量。举例来说，假设一个全向光源向所有方向均匀的辐射能量，辐射强度就能帮我们计算出它在一个单位面积（立体角）内的能量大小：</p>
<p><img alt="" src="../../img/07/01/radiant_intensity.png" /></p>
<p>计算辐射强度的公式如下所示：</p>
<p>
<script type="math/tex; mode=display">
I = \frac{d\Phi}{d\omega}
</script>
</p>
<p>其中<script type="math/tex">I</script>表示辐射通量<script type="math/tex">\Phi</script>除以立体角<script type="math/tex">\omega</script>。</p>
<p>在理解了辐射通量，辐射强度与立体角的概念之后，我们终于可以开始讨论<strong>辐射率</strong>的方程式了。这个方程表示的是，一个拥有辐射强度<script type="math/tex">\Phi</script>的光源在单位面积<script type="math/tex">A</script>，单位立体角<script type="math/tex">\omega</script>上的辐射出的总能量：</p>
<p>
<script type="math/tex; mode=display">
L=\frac{d^2\Phi}{ dA d\omega \cos\theta}
</script>
</p>
<p><img alt="" src="../../img/07/01/radiance.png" /></p>
<p>辐射率是辐射度量学上表示一个区域平面上光线总量的物理量，它受到<def>入射</def>(Incident)（或者来射）光线与平面法线间的夹角<script type="math/tex">\theta</script>的余弦值<script type="math/tex">\cos \theta</script>的影响：当直接辐射到平面上的程度越低时，光线就越弱，而当光线完全垂直于平面时强度最高。这和我们在前面的<a href="../../02%20Lighting/02%20Basic%20Lighting/">基础光照</a>教程中对于漫反射光照的概念相似，其中<script type="math/tex">\cos \theta</script>就直接对应于光线的方向向量和平面法向量的点积：</p>
<pre><code class="language-c++">float cosTheta = dot(lightDir, N);
</code></pre>
<p>辐射率方程很有用，因为它把大部分我们感兴趣的物理量都包含了进去。如果我们把立体角<script type="math/tex">\omega</script>和面积<script type="math/tex">A</script>看作是无穷小的，那么我们就能用辐射率来表示单束光线穿过空间中的一个点的通量。这就使我们可以计算得出作用于单个（片段）点上的单束光线的辐射率，我们实际上把立体角<script type="math/tex">\omega</script>转变为方向向量<script type="math/tex">\omega</script>然后把面<script type="math/tex">A</script>转换为点<script type="math/tex">p</script>。这样我们就能直接在我们的着色器中使用辐射率来计算单束光线对每个片段的作用了。</p>
<p>事实上，当涉及到辐射率时，我们通常关心的是<strong>所有</strong>投射到点<script type="math/tex">p</script>上的光线的总和，而这个和就称为辐射照度或者<def>辐照度</def>(Irradiance)。在理解了辐射率和辐照度的概念之后，让我们再回过头来看看反射率方程：</p>
<p>
<script type="math/tex; mode=display">
L_o(p,\omega_o) = \int\limits_{\Omega} f_r(p,\omega_i,\omega_o) L_i(p,\omega_i) n \cdot \omega_i  d\omega_i
</script>
</p>
<p>我们知道在渲染方程中<script type="math/tex">L</script>代表通过某个无限小的立体角<script type="math/tex">\omega_i</script>在某个点上的辐射率，而立体角可以视作是入射方向向量<script type="math/tex">\omega_i</script>。注意我们利用光线和平面间的入射角的余弦值<script type="math/tex">\cos \theta</script>来计算能量，亦即从辐射率公式<script type="math/tex">L</script>转化至反射率公式时的<script type="math/tex">n \cdot \omega_i</script>。用<script type="math/tex">\omega_o</script>表示观察方向，也就是出射方向，反射率公式计算了点<script type="math/tex">p</script>在<script type="math/tex">\omega_o</script>方向上被反射出来的辐射率<script type="math/tex">L_o(p, \omega_o)</script>的总和。或者换句话说：<script type="math/tex">L_o</script>表示了从<script type="math/tex">\omega_o</script>方向上观察，光线投射到点<script type="math/tex">p</script>上反射出来的辐照度。</p>
<p>基于反射率公式是围绕所有入射辐射率的总和，也就是辐照度来计算的，所以我们需要计算的就不只是是单一的一个方向上的入射光，而是一个以点<script type="math/tex">p</script>为球心的半球领域<script type="math/tex">\Omega</script>内所有方向上的入射光。一个<def>半球领域</def>(Hemisphere)可以描述为以平面法线<script type="math/tex">n</script>为轴所环绕的半个球体：</p>
<p><img alt="" src="../../img/07/01/hemisphere.png" /></p>
<p>为了计算某些面积的值，或者像是在半球领域的问题中计算某一个体积的时候我们会需要用到一种称为<def>积分</def>(Integral)的数学手段，也就是反射率公式中的符号<script type="math/tex">\int</script>，它的运算包含了半球领域<script type="math/tex">\Omega</script>内所有入射方向上的<script type="math/tex">d\omega_i</script> 。积分运算的值等于一个函数曲线的面积，它的计算结果要么是解析解要么就是数值解。由于渲染方程和反射率方程都没有解析解，我们将会用离散的方法来求得这个积分的数值解。这个问题就转化为，在半球领域<script type="math/tex">\Omega</script>中按一定的步长将反射率方程分散求解，然后再按照步长大小将所得到的结果平均化。这种方法被称为黎曼和(<def>Riemann sum</def>) ，我们可以用下面的代码粗略的演示一下：</p>
<pre><code class="language-c++">int steps = 100;
float sum = 0.0f;
vec3 P    = ...;
vec3 Wo   = ...;
vec3 N    = ...;
float dW  = 1.0f / steps;
for(int i = 0; i &lt; steps; ++i)
{
    vec3 Wi = getNextIncomingLightDir(i);
    sum += Fr(p, Wi, Wo) * L(p, Wi) * dot(N, Wi) * dW;
}
</code></pre>
<p>通过利用<code>dW</code>来对所有离散部分进行缩放，其和最后就等于积分函数的总面积或者总体积。这个用来对每个离散步长进行缩放的<code>dW</code>可以认为就是反射率方程中的<script type="math/tex">d\omega_i</script> 。在数学上，用来计算积分的<script type="math/tex">d\omega_i</script> 表示的是一个连续的符号，而我们使用的<code>dW</code>在代码中和它并没有直接的联系（因为它代表的是黎曼和中的离散步长），这样说是为了可以帮助你理解。请牢记，使用离散步长得到的是函数总面积的一个近似值。细心的读者可能已经注意到了，我们可以通过增加离散部分的数量来提高黎曼和的<strong>准确度</strong>(Accuracy)。</p>
<p>反射率方程概括了在半球领域<script type="math/tex">\Omega</script>内，碰撞到了点<script type="math/tex">p</script>上的所有入射方向<script type="math/tex">\omega_i</script> 上的光线的辐射率，并受到<script type="math/tex">f_r</script>的约束，然后返回观察方向上反射光的<script type="math/tex">L_o</script>。正如我们所熟悉的那样，入射光辐射率可以由<a href="../02%20Lighting/">光源</a>处获得，此外还可以利用一个环境贴图来测算所有入射方向上的辐射率，我们将在未来的<a href="../03%20IBL/01%20Diffuse%20irradiance/">IBL</a>教程中讨论这个方法。</p>
<p>现在唯一剩下的未知符号就是<script type="math/tex">f_r</script>了，它被称为<def>BRDF</def>，或者<def>双向反射分布函数</def>(Bidirectional Reflective Distribution Function) ，它的作用是基于表面材质属性来对入射辐射率进行缩放或者加权。</p>
<h2 id="brdf">BRDF</h2>
<p><def>BRDF</def>，或者说<def>双向反射分布函数</def>，它接受入射（光）方向<script type="math/tex">\omega_i</script>，出射（观察）方向<script type="math/tex">\omega_o</script>，平面法线<script type="math/tex">n</script>以及一个用来表示微平面粗糙程度的参数<script type="math/tex">a</script>作为函数的输入参数。BRDF可以近似的求出每束光线对一个给定了材质属性的平面上最终反射出来的光线所作出的贡献程度。举例来说，如果一个平面拥有完全光滑的表面（比如镜面），那么对于所有的入射光线<script type="math/tex">\omega_i</script>（除了一束以外）而言BRDF函数都会返回0.0 ，只有一束与出射光线<script type="math/tex">\omega_o</script>拥有相同（被反射）角度的光线会得到1.0这个返回值。</p>
<p>BRDF基于我们之前所探讨过的微平面理论来近似的求得材质的反射与折射属性。对于一个BRDF，为了实现物理学上的可信度，它必须遵守能量守恒定律，也就是说反射光线的总和永远不能超过入射光线的总量。严格上来说，同样采用<script type="math/tex">\omega_i</script>和<script type="math/tex">\omega_o</script>作为输入参数的 Blinn-Phong光照模型也被认为是一个BRDF。然而由于Blinn-Phong模型并没有遵循能量守恒定律，因此它不被认为是基于物理的渲染。现在已经有很好几种BRDF都能近似的得出物体表面对于光的反应，但是几乎所有实时渲染管线使用的都是一种被称为<def>Cook-Torrance BRDF</def>模型。</p>
<p>Cook-Torrance BRDF兼有漫反射和镜面反射两个部分：</p>
<p>
<script type="math/tex; mode=display">
f_r = k_d f_{lambert} +  k_s f_{cook-torrance}
</script>
</p>
<p>这里的<script type="math/tex">k_d</script>是早先提到过的入射光线中<strong>被折射</strong>部分的能量所占的比率，而<script type="math/tex">k_s</script>是<strong>被反射</strong>部分的比率。BRDF的左侧表示的是漫反射部分，这里用<script type="math/tex">f_{lambert}</script>来表示。它被称为<def>Lambertian漫反射</def>，这和我们之前在漫反射着色中使用的常数因子类似，用如下的公式来表示：</p>
<p>
<script type="math/tex; mode=display">
f_{lambert} = \frac{c}{\pi}
</script>
</p>
<p>
<script type="math/tex">c</script>表示表面颜色（回想一下漫反射表面纹理）。除以<script type="math/tex">\pi</script>是为了对漫反射光进行标准化，因为前面含有BRDF的积分方程是受<script type="math/tex">\pi</script>影响的（我们会在<a href="../03%20IBL/01%20Diffuse%20irradiance/">IBL</a>的教程中探讨这个问题的）。</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>你也许会感到好奇，这个Lambertian漫反射和我们之前经常使用的漫反射到底有什么关系：之前我们是用表面法向量与光照方向向量进行点乘，然后再将结果与平面颜色相乘得到漫反射参数。点乘依然还在，但是却不在BRDF之内，而是转变成为了<script type="math/tex">L_o</script>积分末公式末尾处的<script type="math/tex">n \cdot \omega_i</script> 。</p>
</div>
<p>目前存在着许多不同类型的模型来实现BRDF的漫反射部分，大多看上去都相当真实，但是相应的运算开销也非常的昂贵。不过按照Epic公司给出的结论，Lambertian漫反射模型已经足够应付大多数实时渲染的用途了。</p>
<p>BRDF的镜面反射部分要稍微更高级一些，它的形式如下所示：</p>
<p>
<script type="math/tex; mode=display">
f_{cook-torrance} = \frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)}
</script>
</p>
<p>Cook-Torrance BRDF的镜面反射部分包含三个函数，此外分母部分还有一个标准化因子 。字母D，F与G分别代表着一种类型的函数，各个函数分别用来近似的计算出表面反射特性的一个特定部分。三个函数分别为法线分布函数(Normal <strong>D</strong>istribution Function)，菲涅尔方程(<strong>F</strong>resnel Rquation)和几何函数(<strong>G</strong>eometry Function)：</p>
<ul>
<li><strong>法线分布函数</strong>：估算在受到表面粗糙度的影响下，朝向方向与半程向量一致的微平面的数量。这是用来估算微平面的主要函数。</li>
<li><strong>几何函数</strong>：描述了微平面自成阴影的属性。当一个平面相对比较粗糙的时候，平面表面上的微平面有可能挡住其他的微平面从而减少表面所反射的光线。</li>
<li><strong>菲涅尔方程</strong>：菲涅尔方程描述的是在不同的表面角下表面所反射的光线所占的比率。</li>
</ul>
<p>以上的每一种函数都是用来估算相应的物理参数的，而且你会发现用来实现相应物理机制的每种函数都有不止一种形式。它们有的非常真实，有的则性能高效。你可以按照自己的需求任意选择自己想要的函数的实现方法。英佩游戏公司的Brian Karis对于这些函数的多种近似实现方式进行了大量的<a href="http://graphicrants.blogspot.nl/2013/08/specular-brdf-reference.html">研究</a>。我们将会采用Epic Games在Unreal Engine 4中所使用的函数，其中D使用Trowbridge-Reitz GGX，F使用Fresnel-Schlick近似(Fresnel-Schlick Approximation)，而G使用Smith&rsquo;s Schlick-GGX。</p>
<h3 id="_5">法线分布函数</h3>
<p><def>法线分布函数</def><script type="math/tex">D</script>，从统计学上近似地表示了与某些（半程）向量<script type="math/tex">h</script>取向一致的微平面的比率。举例来说，假设给定向量<script type="math/tex">h</script>，如果我们的微平面中有35%与向量<script type="math/tex">h</script>取向一致，则法线分布函数或者说NDF将会返回0.35。目前有很多种NDF都可以从统计学上来估算微平面的总体取向度，只要给定一些粗糙度的参数。我们马上将要用到的是Trowbridge-Reitz GGX：</p>
<p>
<script type="math/tex; mode=display">
NDF_{GGX TR}(n, h, \alpha) = \frac{\alpha^2}{\pi((n \cdot h)^2 (\alpha^2 - 1) + 1)^2}
</script>
</p>
<p>在这里<script type="math/tex">h</script>表示用来与平面上微平面做比较用的半程向量，而<script type="math/tex">a</script>表示表面粗糙度。</p>
<p>如果我们把<script type="math/tex">h</script>当成是不同粗糙度参数下，平面法向量和光线方向向量之间的中间向量的话，我们可以得到如下图示的效果：</p>
<p><img alt="" src="../../img/07/01/ndf.png" /></p>
<p>当粗糙度很低（也就是说表面很光滑）的时候，与半程向量取向一致的微平面会高度集中在一个很小的半径范围内。由于这种集中性，NDF最终会生成一个非常明亮的斑点。但是当表面比较粗糙的时候，微平面的取向方向会更加的随机。你将会发现与<script type="math/tex">h</script>向量取向一致的微平面分布在一个大得多的半径范围内，但是同时较低的集中性也会让我们的最终效果显得更加灰暗。</p>
<p>使用GLSL代码编写的Trowbridge-Reitz GGX法线分布函数是下面这个样子的：</p>
<pre><code class="language-c++">float D_GGX_TR(vec3 N, vec3 H, float a)
{
    float a2     = a*a;
    float NdotH  = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;

    float nom    = a2;
    float denom  = (NdotH2 * (a2 - 1.0) + 1.0);
    denom        = PI * denom * denom;

    return nom / denom;
}
</code></pre>
<h3 id="_6">几何函数</h3>
<p>几何函数从统计学上近似的求得了微平面间相互遮蔽的比率，这种相互遮蔽会损耗光线的能量。</p>
<p><img alt="" src="../../img/07/01/geometry_shadowing.png" /></p>
<p>与NDF类似，几何函数采用一个材料的粗糙度参数作为输入参数，粗糙度较高的表面其微平面间相互遮蔽的概率就越高。我们将要使用的几何函数是GGX与Schlick-Beckmann近似的结合体，因此又称为Schlick-GGX：</p>
<p>
<script type="math/tex; mode=display">
G_{SchlickGGX}(n, v, k) = \frac{n \cdot v}{(n \cdot v)(1 - k) + k }
</script>
</p>
<p>这里的<script type="math/tex">k</script>是<script type="math/tex">\alpha</script>的重映射(Remapping)，取决于我们要用的是针对直接光照还是针对IBL光照的几何函数:</p>
<p>
<script type="math/tex; mode=display">
k_{direct} = \frac{(\alpha + 1)^2}{8}
</script>
</p>
<p>
<script type="math/tex; mode=display">
k_{IBL} = \frac{\alpha^2}{2}
</script>
</p>
<p>注意，根据你的引擎把粗糙度转化为<script type="math/tex">\alpha</script>的方式不同，得到<script type="math/tex">\alpha</script>的值也有可能不同。在接下来的教程中，我们将会广泛的讨论这个重映射是如何起作用的。</p>
<p>为了有效的估算几何部分，需要将观察方向（几何遮蔽(Geometry Obstruction)）和光线方向向量（几何阴影(Geometry Shadowing)）都考虑进去。我们可以使用<def>史密斯法</def>(Smith&rsquo;s method)来把两者都纳入其中：</p>
<p>
<script type="math/tex; mode=display">
G(n, v, l, k) = G_{sub}(n, v, k) G_{sub}(n, l, k)
</script>
</p>
<p>使用史密斯法与Schlick-GGX作为<script type="math/tex">G_{sub}</script>可以得到如下所示不同粗糙度的视觉效果：</p>
<p><img alt="" src="../../img/07/01/geometry.png" /></p>
<p>几何函数是一个值域为[0.0, 1.0]的乘数，其中白色或者说1.0表示没有微平面阴影，而黑色或者说0.0则表示微平面彻底被遮蔽。</p>
<p>使用GLSL编写的几何函数代码如下：</p>
<pre><code class="language-c++">float GeometrySchlickGGX(float NdotV, float k)
{
    float nom   = NdotV;
    float denom = NdotV * (1.0 - k) + k;

    return nom / denom;
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float k)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx1 = GeometrySchlickGGX(NdotV, k);
    float ggx2 = GeometrySchlickGGX(NdotL, k);

    return ggx1 * ggx2;
}
</code></pre>
<h3 id="_7">菲涅尔方程</h3>
<p>菲涅尔（发音为Freh-nel）方程描述的是被反射的光线对比光线被折射的部分所占的比率，这个比率会随着我们观察的角度不同而不同。当光线碰撞到一个表面的时候，菲涅尔方程会根据观察角度告诉我们被反射的光线所占的百分比。利用这个反射比率和能量守恒原则，我们可以直接得出光线被折射的部分以及光线剩余的能量。</p>
<p>当垂直观察的时候，任何物体或者材质表面都有一个<def>基础反射率</def>(Base Reflectivity)，但是如果以一定的角度往平面上看的时候<a href="http://filmicgames.com/archives/557">所有</a>反光都会变得明显起来。你可以自己尝试一下，用垂直的视角观察你自己的木制/金属桌面，此时一定只有最基本的反射性。但是如果你从近乎90度（译注：应该是指和法线的夹角）的角度观察的话反光就会变得明显的多。如果从理想的90度视角观察，所有的平面理论上来说都能完全的反射光线。这种现象因<def>菲涅尔</def>而闻名，并体现在了菲涅尔方程之中。</p>
<p>菲涅尔方程是一个相当复杂的方程式，不过幸运的是菲涅尔方程可以用<def>Fresnel-Schlick</def>近似法求得近似解：</p>
<p>
<script type="math/tex; mode=display">
F_{Schlick}(h, v, F_0) = F_0 + (1 - F_0) ( 1 - (h \cdot v))^5
</script>
</p>
<p>
<script type="math/tex">F_0</script>表示平面的基础反射率，它是利用所谓<strong>折射指数</strong>(Indices of Refraction)或者说IOR计算得出的。然后正如你可以从球体表面看到的那样，我们越是朝球面掠角的方向上看（此时视线和表面法线的夹角接近90度）菲涅尔现象就越明显，反光就越强：</p>
<p><img alt="" src="../../img/07/01/fresnel.png" /></p>
<p>菲涅尔方程还存在一些细微的问题。其中一个问题是Fresnel-Schlick近似仅仅对<def>电介质</def>或者说非金属表面有定义。对于<def>导体</def>(Conductor)表面（金属），使用它们的折射指数计算基础折射率并不能得出正确的结果，这样我们就需要使用一种不同的菲涅尔方程来对导体表面进行计算。由于这样很不方便，所以我们预计算出平面对于<def>法向入射</def>的结果（<script type="math/tex">F_0</script>，处于0度角，好像直接看向表面一样），然后基于相应观察角的Fresnel-Schlick近似对这个值进行插值，用这种方法来进行进一步的估算。这样我们就能对金属和非金属材质使用同一个公式了。</p>
<p>平面对于法向入射的响应或者说基础反射率可以在一些大型数据库中找到，比如<a href="http://refractiveindex.info/">这个</a>。下面列举的这一些常见数值就是从Naty Hoffman的课程讲义中所得到的：</p>
<table align="center" border="1" rules=rows><tbody>
    <tr>
        <th style="text-align:center;">材料</th><th style="text-align:center;">\(F_0\) (线性)</th><th  style="text-align:center;">\(F_0\) (sRGB)</th><th style="text-align:center;" >颜色</th>
    </tr>
    <tr>
        <td width="200" align="center" >水</td><td width="200" align="center">(0.02, 0.02, 0.02)</td><td width="200"  align="center">(0.15, 0.15, 0.15) </td><td width="60" style="background-color:#050505"></td>
    </tr>
    <tr>
        <td align="center" >塑料/玻璃（低）</td><td align="center" >(0.03, 0.03, 0.03)</td><td align="center" >(0.21, 0.21, 0.21)</td><td style="background-color:#080808"></td>
    </tr>
        <tr>
        <td align="center" >塑料（高）</td><td align="center" >(0.05, 0.05, 0.05)</td><td align="center" >(0.24, 0.24, 0.24)</td><td style="background-color:#0D0D0D"></td>
    </tr>
        <tr>
        <td align="center" >玻璃（高）/红宝石</td><td align="center" >(0.08, 0.08, 0.08)</td><td align="center" >(0.31, 0.31, 0.31)</td><td style="background-color:#141414"></td>
    </tr>
        <tr>
        <td align="center" >钻石</td><td align="center" >(0.17, 0.17, 0.17)</td><td align="center" >(0.45, 0.45, 0.45)</td><td style="background-color:#2B2B2B"></td>
    </tr>
        <tr>
        <td align="center" >铁</td><td align="center" >(0.56, 0.57, 0.58)</td><td align="center" >(0.77, 0.78, 0.78)</td><td style="background-color:#8F9194"></td>
    </tr>
        <tr>
        <td align="center" >铜</td><td align="center" >(0.95, 0.64, 0.54)</td><td align="center" >(0.98, 0.82, 0.76)</td><td style="background-color:#F2A38A"></td>
    </tr>
        <tr>
        <td align="center" >金</td><td align="center" >(1.00, 0.71, 0.29)</td><td align="center" >(1.00, 0.86, 0.57)</td><td style="background-color:#FFB54A"></td>
    </tr>
        <tr>
        <td align="center" >铝</td><td align="center" >(0.91, 0.92, 0.92)</td><td align="center" >(0.96, 0.96, 0.97)</td><td style="background-color:#E8EBEB"></td>
    </tr>
        <tr>
        <td align="center" >银</td><td align="center" >(0.95, 0.93, 0.88)</td><td align="center" >(0.98, 0.97, 0.95)</td><td style="background-color:#F2EDE0"></td>
    </tr>
</table>

<p>这里可以观察到的一个有趣的现象，所有电介质材质表面的基础反射率都不会高于0.17，这其实是例外而非普遍情况。导体材质表面的基础反射率起点更高一些并且（大多）在0.5和1.0之间变化。此外，对于导体或者金属表面而言基础反射率一般是带有色彩的，这也是为什么<script type="math/tex">F_0</script>要用RGB三原色来表示的原因（法向入射的反射率可随波长不同而不同）。这种现象我们<strong>只能</strong>在金属表面观察的到。</p>
<p>这些金属表面相比于电介质表面所独有的特性引出了所谓的<def>金属工作流</def>的概念。也就是我们需要额外使用一个被称为<def>金属度</def>(Metalness)的参数来参与编写表面材质。金属度用来描述一个材质表面是金属还是非金属的。</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>理论上来说，一个表面的金属度应该是二元的：要么是金属要么不是金属，不能两者皆是。但是，大多数的渲染管线都允许在0.0至1.0之间线性的调配金属度。这主要是由于材质纹理精度不足以描述一个拥有诸如细沙/沙状粒子/刮痕的金属表面。通过对这些小的类非金属粒子/刮痕调整金属度值，我们可以获得非常好看的视觉效果。</p>
</div>
<p>通过预先计算电介质与导体的<script type="math/tex">F_0</script>值，我们可以对两种类型的表面使用相同的Fresnel-Schlick近似，但是如果是金属表面的话就需要对基础反射率添加色彩。我们一般是按下面这样来实现的：</p>
<pre><code class="language-c++">vec3 F0 = vec3(0.04);
F0      = mix(F0, surfaceColor.rgb, metalness);
</code></pre>
<p>我们为大多数电介质表面定义了一个近似的基础反射率。<script type="math/tex">F_0</script>取最常见的电解质表面的平均值，这又是一个近似值。不过对于大多数电介质表面而言使用0.04作为基础反射率已经足够好了，而且可以在不需要输入额外表面参数的情况下得到物理可信的结果。然后，基于金属表面特性，我们要么使用电介质的基础反射率要么就使用<script type="math/tex">F_0</script>来作为表面颜色。因为金属表面会吸收所有折射光线而没有漫反射，所以我们可以直接使用表面颜色纹理来作为它们的基础反射率。</p>
<p>Fresnel Schlick近似可以用代码表示为：</p>
<pre><code class="language-c++">vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}
</code></pre>
<p>其中<code>cosTheta</code>是表面法向量<script type="math/tex">n</script>与观察方向<script type="math/tex">v</script>的点乘的结果。</p>
<h3 id="cook-torrance">Cook-Torrance反射率方程</h3>
<p>随着Cook-Torrance BRDF中所有元素都介绍完毕，我们现在可以将基于物理的BRDF纳入到最终的反射率方程当中去了：</p>
<p>
<script type="math/tex; mode=display">
L_o(p,\omega_o) = \int\limits_{\Omega} (k_d\frac{c}{\pi} + k_s\frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)})L_i(p,\omega_i) n \cdot \omega_i  d\omega_i
</script>
</p>
<p>这个方程现在完整的描述了一个基于物理的渲染模型，它现在可以认为就是我们一般意义上理解的基于物理的渲染也就是PBR。如果你还没有能完全理解我们将如何把所有这些数学运算结合到一起并融入到代码当中去的话也不必担心。在下一个教程当中，我们将探索如何实现反射率方程来在我们渲染的光照当中获得更加物理可信的结果，而所有这些零零星星的碎片将会慢慢组合到一起来。</p>
<h2 id="pbr">编写PBR材质</h2>
<p>在了解了PBR后面的数学模型之后，最后我们将通过说明美术师一般是如何编写一个我们可以直接输入PBR的平面物理属性的来结束这部分的讨论。PBR渲染管线所需要的每一个表面参数都可以用纹理来定义或者建模。使用纹理可以让我们逐个片段的来控制每个表面上特定的点对于光线是如何响应的：不论那个点是不是金属，粗糙或者平滑，也不论表面对于不同波长的光会有如何的反应。</p>
<p>在下面你可以看到在一个PBR渲染管线当中经常会碰到的纹理列表，还有将它们输入PBR渲染器所能得到的相应的视觉输出：</p>
<p><img alt="" src="../../img/07/01/textures.png" /></p>
<p><strong>反照率</strong>：<def>反照率</def>(Albedo)纹理为每一个金属的纹素(Texel)（纹理像素）指定表面颜色或者基础反射率。这和我们之前使用过的漫反射纹理相当类似，不同的是所有光照信息都是由一个纹理中提取的。漫反射纹理的图像当中常常包含一些细小的阴影或者深色的裂纹，而反照率纹理中是不会有这些东西的。它应该只包含表面的颜色（或者折射吸收系数）。</p>
<p><strong>法线</strong>：法线贴图纹理和我们之前在<a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/">法线贴图</a>教程中所使用的贴图是完全一样的。法线贴图使我们可以逐片段的指定独特的法线，来为表面制造出起伏不平的假象。</p>
<p><strong>金属度</strong>：金属(Metallic)贴图逐个纹素的指定该纹素是不是金属质地的。根据PBR引擎设置的不同，美术师们既可以将金属度编写为灰度值又可以编写为1或0这样的二元值。</p>
<p><strong>粗糙度</strong>：粗糙度(Roughness)贴图可以以纹素为单位指定某个表面有多粗糙。采样得来的粗糙度数值会影响一个表面的微平面统计学上的取向度。一个比较粗糙的表面会得到更宽阔更模糊的镜面反射（高光），而一个比较光滑的表面则会得到集中而清晰的镜面反射。某些PBR引擎预设采用的是对某些美术师来说更加直观的<def>光滑度</def>(Smoothness)贴图而非粗糙度贴图，不过这些数值在采样之时就马上用（1.0 – 光滑度）转换成了粗糙度。</p>
<p><strong>AO</strong>：<def>环境光遮蔽</def>(Ambient Occlusion)贴图或者说<def>AO</def>贴图为表面和周围潜在的几何图形指定了一个额外的阴影因子。比如如果我们有一个砖块表面，反照率纹理上的砖块裂缝部分应该没有任何阴影信息。然而AO贴图则会把那些光线较难逃逸出来的暗色边缘指定出来。在光照的结尾阶段引入环境遮蔽可以明显的提升你场景的视觉效果。网格/表面的环境遮蔽贴图要么通过手动生成，要么由3D建模软件自动生成。</p>
<p>美术师们可以在纹素级别设置或调整这些基于物理的输入值，还可以以现实世界材料的表面物理性质来建立他们的材质数据。这是PBR渲染管线最大的优势之一，因为不论环境或者光照的设置如何改变这些表面的性质是不会改变的，这使得美术师们可以更便捷地获取物理可信的结果。在PBR渲染管线中编写的表面可以非常方便的在不同的PBR渲染引擎间共享使用，不论处于何种环境中它们看上去都会是正确的，因此看上去也会更自然。</p>
<h2 id="_8">延伸阅读</h2>
<ul>
<li><a href="http://blog.selfshadow.com/publications/s2013-shading-course/hoffman/s2013_pbs_physics_math_notes.pdf">Background: Physics and Math of Shading by Naty Hoffmann</a>：由于在这一篇文章中要谈论的理论点太多，所以这里的理论知识都只是涉及到了皮毛。如果你希望了解更多关于光线背后的物理知识以及它们和PBR理论之间有什么关联的话，<strong>这</strong>才是你需要阅读的资源。</li>
<li><a href="http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf">Real shading in Unreal Engine 4</a>：探讨了Epic Games在他们的Unreal 4引擎中所采用的PBR模型。我们这些教程中主要涉及的PBR系统就是基于他们的PBR模型。</li>
<li><a href="https://www.marmoset.co/toolbag/learn/pbr-theory">Marmoset: PBR Theory</a>：主要针对美术师的PBR介绍，不过仍然是很好的读物。</li>
<li><a href="http://www.codinglabs.net/article_physically_based_rendering.aspx">Coding Labs: Physically based rendering</a>：介绍渲染方程以及它和PBR直接的关系。</li>
<li><a href="http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx">Coding Labs: Physically Based Rendering - Cook–Torrance</a>：介绍了Cook-Torrance BRDF.</li>
<li><a href="http://blog.wolfire.com/2015/10/Physically-based-rendering">Wolfire Games - Physically based rendering</a>：介绍了PBR，由Lukas Orsvärn所著。</li>
</ul>

<div id="disqus_thread"></div>
<script>
    (function() {
        var d = document, s = d.createElement('script');

        s.src = '//learnopengl-cn.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>请启用JavaScript以浏览<a href="https://disqus.com/?ref_noscript" rel="nofollow">Disqus评论。</a></noscript></div>
        </div>

        <footer class="col-md-12">
            <hr>
            
            <center>Powered by <a href="http://www.mkdocs.org/">MkDocs</a> and <a href="http://bootswatch.com/yeti/">Yeti</a></center>
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script>var base_url = '../..';</script>
        <script src="../../js/base.js"></script>
        <script src="../../mathjax/MathJax.js?config=TeX-AMS_HTML"></script>
        <script src="../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">关闭</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">搜索</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            请在下面输入你要搜索的文本（仅支持英文）：
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="搜索..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>
    </body>
</html>