<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="http://learnopengl.com 系列教程的简体中文翻译">
        
        <link rel="canonical" href="https://learnopengl-cn.github.io/08%20Guest%20Articles/2020/01%20Skeletal%20Animation/">
        <link rel="shortcut icon" href="../../../img/favicon.ico">

	<title>骨骼动画 - LearnOpenGL CN</title>

        <link href="../../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../../css/highlight.css">
        <link href="../../../css/base.css" rel="stylesheet">
        <link href="../../../css/style.css" rel="stylesheet">
        <link href="../../../css/admonition_fix.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
          ga('create', 'UA-80323542-1', 'auto');
          ga('send', 'pageview');
        </script>
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../../..">LearnOpenGL CN</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="../../..">主页</a>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">目录 <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
<li >
    <a href="../../../intro/">简介</a>
</li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">入门</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../../01%20Getting%20started/01%20OpenGL/">OpenGL</a>
</li>

        
            
<li >
    <a href="../../../01%20Getting%20started/02%20Creating%20a%20window/">创建窗口</a>
</li>

        
            
<li >
    <a href="../../../01%20Getting%20started/03%20Hello%20Window/">你好，窗口</a>
</li>

        
            
<li >
    <a href="../../../01%20Getting%20started/04%20Hello%20Triangle/">你好，三角形</a>
</li>

        
            
<li >
    <a href="../../../01%20Getting%20started/05%20Shaders/">着色器</a>
</li>

        
            
<li >
    <a href="../../../01%20Getting%20started/06%20Textures/">纹理</a>
</li>

        
            
<li >
    <a href="../../../01%20Getting%20started/07%20Transformations/">变换</a>
</li>

        
            
<li >
    <a href="../../../01%20Getting%20started/08%20Coordinate%20Systems/">坐标系统</a>
</li>

        
            
<li >
    <a href="../../../01%20Getting%20started/09%20Camera/">摄像机</a>
</li>

        
            
<li >
    <a href="../../../01%20Getting%20started/10%20Review/">复习</a>
</li>

        
    </ul>
  </li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">光照</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../../02%20Lighting/01%20Colors/">颜色</a>
</li>

        
            
<li >
    <a href="../../../02%20Lighting/02%20Basic%20Lighting/">基础光照</a>
</li>

        
            
<li >
    <a href="../../../02%20Lighting/03%20Materials/">材质</a>
</li>

        
            
<li >
    <a href="../../../02%20Lighting/04%20Lighting%20maps/">光照贴图</a>
</li>

        
            
<li >
    <a href="../../../02%20Lighting/05%20Light%20casters/">投光物</a>
</li>

        
            
<li >
    <a href="../../../02%20Lighting/06%20Multiple%20lights/">多光源</a>
</li>

        
            
<li >
    <a href="../../../02%20Lighting/07%20Review/">复习</a>
</li>

        
    </ul>
  </li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">模型加载</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../../03%20Model%20Loading/01%20Assimp/">Assimp</a>
</li>

        
            
<li >
    <a href="../../../03%20Model%20Loading/02%20Mesh/">网格</a>
</li>

        
            
<li >
    <a href="../../../03%20Model%20Loading/03%20Model/">模型</a>
</li>

        
    </ul>
  </li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">高级OpenGL</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../../04%20Advanced%20OpenGL/01%20Depth%20testing/">深度测试</a>
</li>

        
            
<li >
    <a href="../../../04%20Advanced%20OpenGL/02%20Stencil%20testing/">模板测试</a>
</li>

        
            
<li >
    <a href="../../../04%20Advanced%20OpenGL/03%20Blending/">混合</a>
</li>

        
            
<li >
    <a href="../../../04%20Advanced%20OpenGL/04%20Face%20culling/">面剔除</a>
</li>

        
            
<li >
    <a href="../../../04%20Advanced%20OpenGL/05%20Framebuffers/">帧缓冲</a>
</li>

        
            
<li >
    <a href="../../../04%20Advanced%20OpenGL/06%20Cubemaps/">立方体贴图</a>
</li>

        
            
<li >
    <a href="../../../04%20Advanced%20OpenGL/07%20Advanced%20Data/">高级数据</a>
</li>

        
            
<li >
    <a href="../../../04%20Advanced%20OpenGL/08%20Advanced%20GLSL/">高级GLSL</a>
</li>

        
            
<li >
    <a href="../../../04%20Advanced%20OpenGL/09%20Geometry%20Shader/">几何着色器</a>
</li>

        
            
<li >
    <a href="../../../04%20Advanced%20OpenGL/10%20Instancing/">实例化</a>
</li>

        
            
<li >
    <a href="../../../04%20Advanced%20OpenGL/11%20Anti%20Aliasing/">抗锯齿</a>
</li>

        
    </ul>
  </li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">高级光照</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../../05%20Advanced%20Lighting/01%20Advanced%20Lighting/">高级光照</a>
</li>

        
            
<li >
    <a href="../../../05%20Advanced%20Lighting/02%20Gamma%20Correction/">Gamma校正</a>
</li>

        
            
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">阴影</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../../05%20Advanced%20Lighting/03%20Shadows/01%20Shadow%20Mapping/">阴影映射</a>
</li>

        
            
<li >
    <a href="../../../05%20Advanced%20Lighting/03%20Shadows/02%20Point%20Shadows/">点阴影</a>
</li>

        
            
<li >
    <a href="../../../05%20Advanced%20Lighting/03%20Shadows/03%20CSM/">CSM</a>
</li>

        
    </ul>
  </li>

        
            
<li >
    <a href="../../../05%20Advanced%20Lighting/04%20Normal%20Mapping/">法线贴图</a>
</li>

        
            
<li >
    <a href="../../../05%20Advanced%20Lighting/05%20Parallax%20Mapping/">视差贴图</a>
</li>

        
            
<li >
    <a href="../../../05%20Advanced%20Lighting/06%20HDR/">HDR</a>
</li>

        
            
<li >
    <a href="../../../05%20Advanced%20Lighting/07%20Bloom/">泛光</a>
</li>

        
            
<li >
    <a href="../../../05%20Advanced%20Lighting/08%20Deferred%20Shading/">延迟着色法</a>
</li>

        
            
<li >
    <a href="../../../05%20Advanced%20Lighting/09%20SSAO/">SSAO</a>
</li>

        
    </ul>
  </li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">PBR</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../../07%20PBR/01%20Theory/">理论</a>
</li>

        
            
<li >
    <a href="../../../07%20PBR/02%20Lighting/">光照</a>
</li>

        
            
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">IBL</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../../07%20PBR/03%20IBL/01%20Diffuse%20irradiance/">漫反射辐照</a>
</li>

        
            
<li >
    <a href="../../../07%20PBR/03%20IBL/02%20Specular%20IBL/">镜面IBL</a>
</li>

        
    </ul>
  </li>

        
    </ul>
  </li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">实战</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../../06%20In%20Practice/01%20Debugging/">调试</a>
</li>

        
            
<li >
    <a href="../../../06%20In%20Practice/02%20Text%20Rendering/">文本渲染</a>
</li>

        
            
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">2D游戏</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../../06%20In%20Practice/2D-Game/01%20Breakout/">Breakout</a>
</li>

        
            
<li >
    <a href="../../../06%20In%20Practice/2D-Game/02%20Setting%20up/">准备工作</a>
</li>

        
            
<li >
    <a href="../../../06%20In%20Practice/2D-Game/03%20Rendering%20Sprites/">渲染精灵</a>
</li>

        
            
<li >
    <a href="../../../06%20In%20Practice/2D-Game/04%20Levels/">关卡</a>
</li>

        
            
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">碰撞</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../../06%20In%20Practice/2D-Game/05%20Collisions/01%20Ball/">球</a>
</li>

        
            
<li >
    <a href="../../../06%20In%20Practice/2D-Game/05%20Collisions/02%20Collision%20detection/">碰撞检测</a>
</li>

        
            
<li >
    <a href="../../../06%20In%20Practice/2D-Game/05%20Collisions/03%20Collision%20resolution/">碰撞处理</a>
</li>

        
    </ul>
  </li>

        
            
<li >
    <a href="../../../06%20In%20Practice/2D-Game/06%20Particles/">粒子</a>
</li>

        
            
<li >
    <a href="../../../06%20In%20Practice/2D-Game/07%20Postprocessing/">后期处理</a>
</li>

        
            
<li >
    <a href="../../../06%20In%20Practice/2D-Game/08%20Powerups/">道具</a>
</li>

        
            
<li >
    <a href="../../../06%20In%20Practice/2D-Game/09%20Audio/">音效</a>
</li>

        
            
<li >
    <a href="../../../06%20In%20Practice/2D-Game/10%20Render%20Text/">渲染文本</a>
</li>

        
            
<li >
    <a href="../../../06%20In%20Practice/2D-Game/11%20Final%20thoughts/">结语</a>
</li>

        
    </ul>
  </li>

        
    </ul>
  </li>

                    
                        
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">Guest Articles</a>
    <ul class="dropdown-menu">
        
            
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">2020</a>
    <ul class="dropdown-menu">
        
            
<li class="active">
    <a href="./">骨骼动画</a>
</li>

        
    </ul>
  </li>

        
            
  <li class="dropdown-submenu">
    <a tabindex="-1" class="nav-title">2022</a>
    <ul class="dropdown-menu">
        
            
<li >
    <a href="../../2022/03%20Area%20Lights/">区域光</a>
</li>

        
    </ul>
  </li>

        
    </ul>
  </li>

                    
                        
<li >
    <a href="../../../legacy/">历史存档</a>
</li>

                    
                    </ul>
                </li>
            
            
            
                <li >
                    <a href="../../../code_repo/">代码仓库</a>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> 搜索
                    </a>
                </li>
                <li >
                    <a rel="next" href="../../../06%20In%20Practice/2D-Game/11%20Final%20thoughts/">
                        <i class="fa fa-arrow-left"></i> 上一节
                    </a>
                </li>
                <li >
                    <a rel="prev" href="../../2022/03%20Area%20Lights/">
                        下一节 <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
                <li>
                    <a href="https://github.com/LearnOpenGL-CN/LearnOpenGL-CN">
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
                <li>
                    <a href="https://www.paypal.me/learnopengl/">
                            <img class="paypal" src="/img/paypal_logo.png" alt="">
                        支持原作者
                    </a>
                </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#_1">骨骼动画</a></li>
        
            <li><a href="#_2">插值</a></li>
        
            <li><a href="#_3">动画模型的组件：蒙皮、骨骼和关键帧</a></li>
        
            <li><a href="#assimp">Assimp如何保存动画数据</a></li>
        
            <li><a href="#_4">多个骨骼对顶点的影响</a></li>
        
            <li><a href="#_5">最后让我们写代码</a></li>
        
            <li><a href="#_6">骨骼、动画和动画制作类</a></li>
        
            <li><a href="#_7">让我们动起来</a></li>
        
            <li><a href="#_8">延伸阅读</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h1 id="_1">骨骼动画</h1>
<table>
<thead>
<tr>
<th>原文</th>
<th><a href="https://learnopengl.com/Guest-Articles/2020/Skeletal-Animation">Skeletal-Animation</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>作者</td>
<td>Ankit Singh Kushwah</td>
</tr>
<tr>
<td>翻译</td>
<td><a href="https://github.com/orbitgw/">orbitgw</a></td>
</tr>
<tr>
<td>校对</td>
<td><a href="https://github.com/orbitgw/">orbitgw</a></td>
</tr>
</tbody>
</table>
<p>3D动画可以让我们的游戏栩栩如生。3D世界中的物体，比如人类和动物，当它们做某些事情移动四肢时，比如走路、跑步和攻击，会使我们感到更生动。本篇教程是关于你们一直在等待的骨骼动画。我们将首先彻底理解这个概念，然后了解使用Assimp制作3D模型动画所需的数据。我建议您完成本教程的<a href="../03/01%20Assimp.md">模型加载</a>部分，因为本教程代码将从那里继续。你仍然可以理解这个概念，并以自己的方式实现它。所以让我们开始吧。</p>
<h2 id="_2">插值</h2>
<p>要了解动画是如何工作的基础，我们需要了解插值(Interpolation)的概念。插值可以定义为随着时间的推移而发生的事情。就像敌人在时间T上从A点移动到B点一样，即随着时间的推移发生平移。炮塔平滑旋转以面对目标，即随着时间的推移发生旋转，树在时间T内从尺寸A放大到尺寸B，即随时间推移发生缩放。</p>
<div class="admonition note">
<p class="admonition-title">译注</p>
<p>(动画)插值就是<strong>关键帧</strong>的中间值。比如我们使用Blender制作动画，不需要设置每一帧的骨骼位置，只需要在几个关键帧中记录它们的位置，旋转，缩放等等信息。然后由程序自动计算出的中间的过渡帧就是我们的插值。通常插值可以使用曲线描述，比如我们的贝塞尔曲线。</p>
</div>
<p>用于平移和缩放的简单插值方程如下所示：</p>
<p>
<script type="math/tex; mode=display">
a = a \cdot (1 - t) + b \cdot t
</script>
</p>
<p>它被称为线性插值方程或Lerp。对于旋转，我们不能使用向量。原因是，如果我们继续尝试在X（俯仰）、Y（偏航）和Z（滚转）的向量上使用线性插值方程，插值就不会是线性的。你会遇到一些奇怪的问题，比如Gimbal Lock（请参阅下面的参考资料部分了解它）。为了避免这个问题，我们使用四元数进行旋转。四元数提供了一种叫做球面插值或Slerp方程的东西，它给出了与Lerp相同的结果，但对于两个旋转A和B。我无法解释这个方程是如何工作的，因为它目前不在范围内。您可以查看下面的参考资料部分来理解四元数。</p>
<h2 id="_3">动画模型的组件：蒙皮、骨骼和关键帧</h2>
<p>动画的整个过程始于添加第一个组件，即blender或Maya等软件中的蒙皮(Skin)。蒙皮只不过是网格(Mesh)，它为模型添加了视觉方面，告诉观察者它的外观。但是，如果你想移动任何网格，那么就像现实世界一样，你需要添加骨骼。你可以看到下面的图片来了解它在blender等软件中的外观。</p>
<p><img alt="skin" src="../../../img/08/01/skin.png" />
<img alt="bones" src="../../../img/08/01/bones.png" />
<img alt="skin and bones" src="../../../img/08/01/merged.png" /></p>
<p>这些骨头通常是以分层的方式添加给人类和动物等角色的，原因很明显。我们想要四肢之间的父子关系(parent-child relationship)。例如，如果我们移动右肩，那么我们的右二头肌、前臂、手和手指也应该移动。这就是层次结构的样子：</p>
<p><img alt="parent_child" src="../../../img/08/01/parent_child.png" /></p>
<p>在上图中，如果你抓住髋骨(hip bone)并移动它，所有的肢体都会受到它的移动的影响。</p>
<p>此时，我们已经准备好为动画创建关键帧了。关键帧是动画中不同时间点的姿势。我们将在这些关键帧之间进行插值，以便在代码中从一个姿势平滑地过渡到另一个姿势。下面您可以看到如何为简单的4帧跳跃动画创建姿势：</p>
<p><img alt="poses" src="../../../img/08/01/poses.gif" />
<img alt="interpolating" src="../../../img/08/01/interpolating.gif" /></p>
<h2 id="assimp">Assimp如何保存动画数据</h2>
<p>我们马上就会到代码部分，但首先我们需要了解assimp是如何保存导入的动画数据的。看下图：</p>
<p><img alt="assimp1" src="../../../img/08/01/assimp1.jpeg" /></p>
<p>就像<a href="../03/01%20Assimp.md">模型加载</a>部分一样，我们将从<code>aiScene</code>指针开始，该指针包含指向根节点的指针，然后看看我们这里有什么，一个动画数组。这个<code>aiAnimation</code>数组包含一般信息，比如动画的持续时间，这里表示为<code>mDuration</code>，然后我们有一个<code>mTicksPerSecond</code>变量，它控制我们应该在帧之间插值的速度。如果您还记得上一节中的动画有关键帧。类似地，<code>aiAnimation</code>包含一个名为<code>Channels</code>的<code>aiNodeAnim</code>数组。此数组包含将要参与动画的所有骨骼及其关键帧。一个<code>aiNodeAnim</code>包含骨骼的名称，你会发现在这里插入三种类型的关键点，平移、旋转和缩放。</p>
<p>好吧，还有最后一件事我们需要理解，并且很乐意去做的一件事就是写代码。</p>
<h2 id="_4">多个骨骼对顶点的影响</h2>
<p>当我们弯曲前臂时，我们会看到我们的二头肌弹出。我们也可以说前臂骨骼的变形正在影响我们肱二头肌上的顶点。类似地，可能有多个骨骼影响网格中的单个顶点。对于像固体金属机器人这样的角色，所有前臂顶点都只会受到前臂骨骼的影响，但对于像人类、动物等角色，可能有多达4块骨骼可以影响一个顶点。让我们看看assimp是如何存储这些信息的：</p>
<p><img alt="assimp2" src="../../../img/08/01/assimp2.jpeg" /></p>
<p>我们再次从<code>aiScene</code>指针开始，该指针包含所有<code>aiMeshes</code>的数组。每个aiMesh对象都有一个<code>aiBone</code>数组，其中包含诸如此<code>aiBone</code>将对网格上的顶点集产生多大影响之类的信息。<code>aiBone</code>包含骨骼的名称，这是一个<code>aiVertexWeight</code>数组，基本上告诉此<code>aiBone</code>对网格上的顶点有多大影响。现在我们有了<code>aiBone</code>的另一个成员，它是<code>offsetMatrix</code>。这是一个4x4矩阵，用于将顶点从模型空间转换到骨骼空间。你可以在下面的图片中看到这一点：</p>
<p><img alt="mesh_space" src="../../../img/08/01/mesh_space.png" />
<img alt="bone_space" src="../../../img/08/01/bone_space.png" /></p>
<p>当顶点位于骨骼空间中时，它们将按照预期相对于骨骼进行变换。您很快就会在代码中看到这一点。</p>
<h2 id="_5">最后让我们写代码</h2>
<p>谢谢你走到这一步。我们将从直接查看最终结果开始，这是我们的最终顶点着色器代码。这将给我们很好的感觉，我们最终需要什么。</p>
<pre><code class="language-c++">#version 430 core

layout(location = 0) in vec3 pos;
layout(location = 1) in vec3 norm;
layout(location = 2) in vec2 tex;
layout(location = 5) in ivec4 boneIds; 
layout(location = 6) in vec4 weights;

uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;

const int MAX_BONES = 100;
const int MAX_BONE_INFLUENCE = 4;
uniform mat4 finalBonesMatrices[MAX_BONES];

out vec2 TexCoords;

void main()
{
    vec4 totalPosition = vec4(0.0f);
    for(int i = 0 ; i &lt; MAX_BONE_INFLUENCE ; i++)
    {
        if(boneIds[i] == -1) 
            continue;
        if(boneIds[i] &gt;=MAX_BONES) 
        {
            totalPosition = vec4(pos,1.0f);
            break;
        }
        vec4 localPosition = finalBonesMatrices[boneIds[i]] * vec4(pos,1.0f);
        totalPosition += localPosition * weights[i];
        vec3 localNormal = mat3(finalBonesMatrices[boneIds[i]]) * norm;
    }

    mat4 viewModel = view * model;
    gl_Position =  projection * viewModel * totalPosition;
    TexCoords = tex;
}
</code></pre>
<p>片段着色器与<a href="../03/03%20Model.md">这篇教程</a>中的保持相同。从顶部开始，您可以看到两个新的属性布局声明。第一个骨骼ID，第二个是重量。我们还有一个统一的数组<code>finalBonesMatrix</code>，它存储所有骨骼的变换。<code>boneIds</code>包含用于读取最终<code>BonesMatrix</code>数组并将这些变换应用于pos顶点的索引，其各自的权重存储在权重数组中。这发生在上面循环的内部。现在，让我们先在Mesh类中添加对骨骼重量的支持：</p>
<pre><code class="language-c++">#define MAX_BONE_INFLUENCE 4

struct Vertex {
    // position
    glm::vec3 Position;
    // normal
    glm::vec3 Normal;
    // texCoords
    glm::vec2 TexCoords;

    // tangent
    glm::vec3 Tangent;
    // bitangent
    glm::vec3 Bitangent;

    //bone indexes which will influence this vertex
    int m_BoneIDs[MAX_BONE_INFLUENCE];
    //weights from each bone
    float m_Weights[MAX_BONE_INFLUENCE];

};
</code></pre>
<p>我们为顶点添加了两个新属性，就像我们在顶点着色器中看到的那样。现在，让我们将它们加载到GPU缓冲区中，就像我们的<code>Mesh::setupMesh</code>函数中的其他属性一样：</p>
<pre><code class="language-c++">class Mesh
{
    ...

    void setupMesh()
    {
        ....

        // ids
        glEnableVertexAttribArray(3);
        glVertexAttribIPointer(3, 4, GL_INT, sizeof(Vertex), (void*)offsetof(Vertex, m_BoneIDs));

        // weights
        glEnableVertexAttribArray(4);
        glVertexAttribPointer(4, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), 
            (void*)offsetof(Vertex, m_Weights));   

        ...
    }    
    ...
}
</code></pre>
<p>就像以前一样，只是现在我们为<code>boneID</code>和<code>weights</code>添加了3个和4个布局位置ID。这里需要注意的一件重要的事情是我们如何传递<code>boneID</code>的数据。我们使用的是<code>glVertexAttribIPointer</code>，并将<code>GL_INT</code>作为第三个参数传递。</p>
<p>现在我们可以从assimp数据结构中提取骨骼重量信息。让我们在Model类中进行一些更改：</p>
<pre><code class="language-c++">struct BoneInfo
{
    /*id is index in finalBoneMatrices*/
    int id;

    /*offset matrix transforms vertex from model space to bone space*/
    glm::mat4 offset;

};
</code></pre>
<p>此<code>BoneInfo</code>将存储我们的偏移矩阵，以及一个唯一的id，该id将用作索引，将其存储在我们之前在着色器中看到的最终<code>BoneMatrices</code>数组中。现在我们将在Model中添加骨量提取支持：</p>
<pre><code class="language-c++">class Model 
{
private:
    ...
    std::map&lt;string, BoneInfo&gt; m_BoneInfoMap; //
    int m_BoneCounter = 0;

    auto&amp; GetBoneInfoMap() { return m_BoneInfoMap; }
    int&amp; GetBoneCount() { return m_BoneCounter; }    
    ...
    void SetVertexBoneDataToDefault(Vertex&amp; vertex)
    {
        for (int i = 0; i &lt; MAX_BONE_WEIGHTS; i++)
        {
            vertex.m_BoneIDs[i] = -1;
            vertex.m_Weights[i] = 0.0f;
        }
    }

    Mesh processMesh(aiMesh* mesh, const aiScene* scene)
    {
        vector vertices;
        vector indices;
        vector textures;

        for (unsigned int i = 0; i &lt; mesh-&gt;mNumVertices; i++)
        {
            Vertex vertex;

            SetVertexBoneDataToDefault(vertex);

            vertex.Position = AssimpGLMHelpers::GetGLMVec(mesh-&gt;mVertices[i]);
            vertex.Normal = AssimpGLMHelpers::GetGLMVec(mesh-&gt;mNormals[i]);

            if (mesh-&gt;mTextureCoords[0])
            {
                glm::vec2 vec;
                vec.x = mesh-&gt;mTextureCoords[0][i].x;
                vec.y = mesh-&gt;mTextureCoords[0][i].y;
                vertex.TexCoords = vec;
            }
            else
                vertex.TexCoords = glm::vec2(0.0f, 0.0f);

            vertices.push_back(vertex);
        }
        ...
        ExtractBoneWeightForVertices(vertices,mesh,scene);

        return Mesh(vertices, indices, textures);
    }

    void SetVertexBoneData(Vertex&amp; vertex, int boneID, float weight)
    {
        for (int i = 0; i &lt; MAX_BONE_WEIGHTS; ++i)
        {
            if (vertex.m_BoneIDs[i] &lt; 0)
            {
                vertex.m_Weights[i] = weight;
                vertex.m_BoneIDs[i] = boneID;
                break;
            }
        }
    }

    void ExtractBoneWeightForVertices(std::vector&amp; vertices, aiMesh* mesh, const aiScene* scene)
    {
        for (int boneIndex = 0; boneIndex &lt; mesh-&gt;mNumBones; ++boneIndex)
        {
            int boneID = -1;
            std::string boneName = mesh-&gt;mBones[boneIndex]-&gt;mName.C_Str();
            if (m_BoneInfoMap.find(boneName) == m_BoneInfoMap.end())
            {
                BoneInfo newBoneInfo;
                newBoneInfo.id = m_BoneCounter;
                newBoneInfo.offset = AssimpGLMHelpers::ConvertMatrixToGLMFormat(
                    mesh-&gt;mBones[boneIndex]-&gt;mOffsetMatrix);
                m_BoneInfoMap[boneName] = newBoneInfo;
                boneID = m_BoneCounter;
                m_BoneCounter++;
            }
            else
            {
                boneID = m_BoneInfoMap[boneName].id;
            }
            assert(boneID != -1);
            auto weights = mesh-&gt;mBones[boneIndex]-&gt;mWeights;
            int numWeights = mesh-&gt;mBones[boneIndex]-&gt;mNumWeights;

            for (int weightIndex = 0; weightIndex &lt; numWeights; ++weightIndex)
            {
                int vertexId = weights[weightIndex].mVertexId;
                float weight = weights[weightIndex].mWeight;
                assert(vertexId &lt;= vertices.size());
                SetVertexBoneData(vertices[vertexId], boneID, weight);
            }
        }
    }
    ...
};
</code></pre>
<p>我们首先声明一个映射<code>m_BoneInfoMap</code>和一个计数器<code>m_BoneCounter</code>，一旦我们读取到一个新的骨骼，它就会增加。我们在前面的图表中看到，每个<code>aiMesh</code>都包含与<code>aiMesh</code>关联的所有<code>aiBone</code>。骨量提取的整个过程都是从<code>processMesh</code>函数开始的。对于每个循环迭代，我们通过调用函数<code>SetVertexBoneDataToDefault</code>将<code>m_BoneID</code>和<code>m_Weights</code>设置为其默认值。就在<code>processMesh</code>函数结束之前，我们调用<code>ExtractBoneWeightData</code>。在<code>ExtractBoneWeightData</code>中，我们为每个aiBone运行for循环，并检查该骨骼是否已存在于<code>m_BoneInfoMap</code>中。如果我们找不到它，那么它被认为是一块新骨头，我们创建一个带有id的新<code>BoneInfo</code>，并将其关联的<code>mOffsetMatrix</code>存储到它。然后我们将这个新<code>BoneIInfo</code>存储在<code>m_BoneInfoMap</code>中，然后我们递增<code>m_BoneCounter</code>计数器，为下一块骨头创建一个id。如果我们在<code>m_BoneInfoMap</code>中找到骨骼名称，那么这意味着该骨骼会影响超出其范围的网格顶点。所以我们取它的Id，进一步了解它会影响哪些顶点。</p>
<p>需要注意的一点是，我们正在调用<code>AssimpGLMHelpers::ConvertMatrixToGLMFormat</code>。Assimp以与GLM不同的格式存储其矩阵数据，因此此函数仅为我们提供GLM格式的矩阵。</p>
<p>我们已经提取了骨骼的<code>offsetMatrix</code>，现在我们将简单地迭代其<code>aiVertexWeightarray</code>，提取将受此骨骼影响的所有顶点索引及其各自的权重，并调用<code>SetVertexBoneData</code>以使用提取的信息填充<code>Vertex.boneIds</code>和<code>Vertex.weights</code>。</p>
<p>呜！到这里你应当休息一下。</p>
<h2 id="_6">骨骼、动画和动画制作类</h2>
<p>这是类的视图：</p>
<p><img alt="bird_eye_view" src="../../../img/08/01/bird_eye_view.png" /></p>
<p>让我们提醒自己我们正在努力实现什么。对于每个渲染帧，我们希望平滑地插值继承中的所有骨骼，并获得它们的最终变换矩阵，这些矩阵将提供给着色器统一的finalBonesMatrix。以下是每个类的内容：</p>
<p><strong>Bone</strong> : 从aiNodeAnim读取所有关键帧数据的单个骨骼。它还将根据当前动画时间在关键帧之间进行插值，即平移、缩放和旋转。</p>
<p><strong>AssimpNodeData</strong> : 这个结构体将帮助我们将动画从Assimp提取出来。</p>
<p><strong>Animation</strong> : 从aiAnimation读取数据并创建Bones的继承记录的资源。</p>
<p><strong>Animator</strong> : 这将读取AssimpNodeData的继承方法，以递归方式插入所有骨骼，然后为我们准备所需的最终骨骼转换矩阵。</p>
<p>这就是代码：</p>
<pre><code class="language-c++">struct KeyPosition
{
    glm::vec3 position;
    float timeStamp;
};

struct KeyRotation
{
    glm::quat orientation;
    float timeStamp;
};

struct KeyScale
{
    glm::vec3 scale;
    float timeStamp;
};

class Bone
{
private:
    std::vector&lt;KeyPosition&gt; m_Positions;
    std::vector&lt;KeyRotation&gt; m_Rotations;
    std::vector&lt;KeyScale&gt; m_Scales;
    int m_NumPositions;
    int m_NumRotations;
    int m_NumScalings;

    glm::mat4 m_LocalTransform;
    std::string m_Name;
    int m_ID;

public:

/*reads keyframes from aiNodeAnim*/
    Bone(const std::string&amp; name, int ID, const aiNodeAnim* channel)
        :
        m_Name(name),
        m_ID(ID),
        m_LocalTransform(1.0f)
    {
        m_NumPositions = channel-&gt;mNumPositionKeys;

        for (int positionIndex = 0; positionIndex &lt; m_NumPositions; ++positionIndex)
        {
            aiVector3D aiPosition = channel-&gt;mPositionKeys[positionIndex].mValue;
            float timeStamp = channel-&gt;mPositionKeys[positionIndex].mTime;
            KeyPosition data;
            data.position = AssimpGLMHelpers::GetGLMVec(aiPosition);
            data.timeStamp = timeStamp;
            m_Positions.push_back(data);
        }

        m_NumRotations = channel-&gt;mNumRotationKeys;
        for (int rotationIndex = 0; rotationIndex &lt; m_NumRotations; ++rotationIndex)
        {
            aiQuaternion aiOrientation = channel-&gt;mRotationKeys[rotationIndex].mValue;
            float timeStamp = channel-&gt;mRotationKeys[rotationIndex].mTime;
            KeyRotation data;
            data.orientation = AssimpGLMHelpers::GetGLMQuat(aiOrientation);
            data.timeStamp = timeStamp;
            m_Rotations.push_back(data);
        }

        m_NumScalings = channel-&gt;mNumScalingKeys;
        for (int keyIndex = 0; keyIndex &lt; m_NumScalings; ++keyIndex)
        {
            aiVector3D scale = channel-&gt;mScalingKeys[keyIndex].mValue;
            float timeStamp = channel-&gt;mScalingKeys[keyIndex].mTime;
            KeyScale data;
            data.scale = AssimpGLMHelpers::GetGLMVec(scale);
            data.timeStamp = timeStamp;
            m_Scales.push_back(data);
        }
    }

    /*interpolates  b/w positions,rotations &amp; scaling keys based on the curren time of 
    the animation and prepares the local transformation matrix by combining all keys 
    tranformations*/
    void Update(float animationTime)
    {
        glm::mat4 translation = InterpolatePosition(animationTime);
        glm::mat4 rotation = InterpolateRotation(animationTime);
        glm::mat4 scale = InterpolateScaling(animationTime);
        m_LocalTransform = translation * rotation * scale;
    }

    glm::mat4 GetLocalTransform() { return m_LocalTransform; }
    std::string GetBoneName() const { return m_Name; }
    int GetBoneID() { return m_ID; }


    /* Gets the current index on mKeyPositions to interpolate to based on 
    the current animation time*/
    int GetPositionIndex(float animationTime)
    {
        for (int index = 0; index &lt; m_NumPositions - 1; ++index)
        {
            if (animationTime &lt; m_Positions[index + 1].timeStamp)
                return index;
        }
        assert(0);
    }

    /* Gets the current index on mKeyRotations to interpolate to based on the 
    current animation time*/
    int GetRotationIndex(float animationTime)
    {
        for (int index = 0; index &lt; m_NumRotations - 1; ++index)
        {
            if (animationTime &lt; m_Rotations[index + 1].timeStamp)
                return index;
        }
        assert(0);
    }

    /* Gets the current index on mKeyScalings to interpolate to based on the 
    current animation time */
    int GetScaleIndex(float animationTime)
    {
        for (int index = 0; index &lt; m_NumScalings - 1; ++index)
        {
            if (animationTime &lt; m_Scales[index + 1].timeStamp)
                return index;
        }
        assert(0);
    }

private:

    /* Gets normalized value for Lerp &amp; Slerp*/
    float GetScaleFactor(float lastTimeStamp, float nextTimeStamp, float animationTime)
    {
        float scaleFactor = 0.0f;
        float midWayLength = animationTime - lastTimeStamp;
        float framesDiff = nextTimeStamp - lastTimeStamp;
        scaleFactor = midWayLength / framesDiff;
        return scaleFactor;
    }

    /*figures out which position keys to interpolate b/w and performs the interpolation 
    and returns the translation matrix*/
    glm::mat4 InterpolatePosition(float animationTime)
    {
        if (1 == m_NumPositions)
            return glm::translate(glm::mat4(1.0f), m_Positions[0].position);

        int p0Index = GetPositionIndex(animationTime);
        int p1Index = p0Index + 1;
        float scaleFactor = GetScaleFactor(m_Positions[p0Index].timeStamp,
            m_Positions[p1Index].timeStamp, animationTime);
        glm::vec3 finalPosition = glm::mix(m_Positions[p0Index].position,
            m_Positions[p1Index].position, scaleFactor);
        return glm::translate(glm::mat4(1.0f), finalPosition);
    }

    /*figures out which rotations keys to interpolate b/w and performs the interpolation 
    and returns the rotation matrix*/
    glm::mat4 InterpolateRotation(float animationTime)
    {
        if (1 == m_NumRotations)
        {
            auto rotation = glm::normalize(m_Rotations[0].orientation);
            return glm::toMat4(rotation);
        }

        int p0Index = GetRotationIndex(animationTime);
        int p1Index = p0Index + 1;
        float scaleFactor = GetScaleFactor(m_Rotations[p0Index].timeStamp,
            m_Rotations[p1Index].timeStamp, animationTime);
        glm::quat finalRotation = glm::slerp(m_Rotations[p0Index].orientation,
            m_Rotations[p1Index].orientation, scaleFactor);
        finalRotation = glm::normalize(finalRotation);
        return glm::toMat4(finalRotation);
    }

    /*figures out which scaling keys to interpolate b/w and performs the interpolation 
    and returns the scale matrix*/
    glm::mat4 Bone::InterpolateScaling(float animationTime)
    {
        if (1 == m_NumScalings)
            return glm::scale(glm::mat4(1.0f), m_Scales[0].scale);

        int p0Index = GetScaleIndex(animationTime);
        int p1Index = p0Index + 1;
        float scaleFactor = GetScaleFactor(m_Scales[p0Index].timeStamp,
            m_Scales[p1Index].timeStamp, animationTime);
        glm::vec3 finalScale = glm::mix(m_Scales[p0Index].scale, m_Scales[p1Index].scale
            , scaleFactor);
        return glm::scale(glm::mat4(1.0f), finalScale);
    }

};
</code></pre>
<p>我们首先为我们的键类型创建3个结构。每个结构都有一个值和一个时间戳。时间戳告诉我们在动画的哪个点需要插值到它的值。Bone有一个构造函数，它从<code>aiNodeAnim</code>读取密钥并将密钥及其时间戳存储到<code>mPositionKeys</code>、<code>mRotationKeys</code>和<code>mScalingKeys</code>。主要插值过程从更新(float animationTime)开始，该过程在每帧调用一次。此函数调用所有键类型的相应插值函数，并组合所有最终插值结果，并将其存储到4x4矩阵<code>m_LocalTransform</code>中。平移和缩放关键点的插值函数相似，但对于旋转，我们使用Slerp在四元数之间进行插值。Lerp和Slerp都有3个论点。第一个参数取最后一个键，第二个参数取下一个键和第三个参数取范围为0-1的值，我们在这里称之为比例因子。让我们看看如何在函数<code>GetScaleFactor</code>中计算这个比例因子：</p>
<p><img alt="" src="../../../img/08/01/scale_factor.png" /></p>
<p>在代码中：</p>
<p><strong>float midWayLength = animationTime - lastTimeStamp;</strong></p>
<p><strong>float framesDiff = nextTimeStamp - lastTimeStamp;</strong></p>
<p><strong>scaleFactor = midWayLength / framesDiff;</strong></p>
<p>现在让我们继续转到<strong>Animation</strong>类：</p>
<pre><code class="language-c++">struct AssimpNodeData
{
    glm::mat4 transformation;
    std::string name;
    int childrenCount;
    std::vector&lt;AssimpNodeData&gt; children;
};

class Animation
{
public:
    Animation() = default;

    Animation(const std::string&amp; animationPath, Model* model)
    {
        Assimp::Importer importer;
        const aiScene* scene = importer.ReadFile(animationPath, aiProcess_Triangulate);
        assert(scene &amp;&amp; scene-&gt;mRootNode);
        auto animation = scene-&gt;mAnimations[0];
        m_Duration = animation-&gt;mDuration;
        m_TicksPerSecond = animation-&gt;mTicksPerSecond;
        ReadHeirarchyData(m_RootNode, scene-&gt;mRootNode);
        ReadMissingBones(animation, *model);
    }

    ~Animation()
    {
    }

    Bone* FindBone(const std::string&amp; name)
    {
        auto iter = std::find_if(m_Bones.begin(), m_Bones.end(),
            [&amp;](const Bone&amp; Bone)
            {
                return Bone.GetBoneName() == name;
            }
        );
        if (iter == m_Bones.end()) return nullptr;
        else return &amp;(*iter);
    }


    inline float GetTicksPerSecond() { return m_TicksPerSecond; }

    inline float GetDuration() { return m_Duration;}

    inline const AssimpNodeData&amp; GetRootNode() { return m_RootNode; }

    inline const std::map&lt;std::string,BoneInfo&gt;&amp; GetBoneIDMap() 
    { 
        return m_BoneInfoMap;
    }

private:
    void ReadMissingBones(const aiAnimation* animation, Model&amp; model)
    {
        int size = animation-&gt;mNumChannels;

        auto&amp; boneInfoMap = model.GetBoneInfoMap();//getting m_BoneInfoMap from Model class
        int&amp; boneCount = model.GetBoneCount(); //getting the m_BoneCounter from Model class

        //reading channels(bones engaged in an animation and their keyframes)
        for (int i = 0; i &lt; size; i++)
        {
            auto channel = animation-&gt;mChannels[i];
            std::string boneName = channel-&gt;mNodeName.data;

            if (boneInfoMap.find(boneName) == boneInfoMap.end())
            {
                boneInfoMap[boneName].id = boneCount;
                boneCount++;
            }
            m_Bones.push_back(Bone(channel-&gt;mNodeName.data,
                boneInfoMap[channel-&gt;mNodeName.data].id, channel));
        }

        m_BoneInfoMap = boneInfoMap;
    }

    void ReadHeirarchyData(AssimpNodeData&amp; dest, const aiNode* src)
    {
        assert(src);

        dest.name = src-&gt;mName.data;
        dest.transformation = AssimpGLMHelpers::ConvertMatrixToGLMFormat(src-&gt;mTransformation);
        dest.childrenCount = src-&gt;mNumChildren;

        for (int i = 0; i &lt; src-&gt;mNumChildren; i++)
        {
            AssimpNodeData newData;
            ReadHeirarchyData(newData, src-&gt;mChildren[i]);
            dest.children.push_back(newData);
        }
    }
    float m_Duration;
    int m_TicksPerSecond;
    std::vector&lt;Bone&gt; m_Bones;
    AssimpNodeData m_RootNode;
    std::map&lt;std::string, BoneInfo&gt; m_BoneInfoMap;
};
</code></pre>
<p>在这里，动画对象的创建从构造函数开始。这需要两个论点。首先，动画文件的路径&amp;第二个参数是该动画的模型。稍后您将看到我们为什么需要此模型参考。然后，我们创建一个<code>Assimp::Importer</code>来读取动画文件，然后进行断言检查，如果找不到动画，该检查将引发错误。然后我们读取一般的动画数据，比如这个动画有多长，即<code>mDuration</code>和由<code>mTicksPerSecond</code>表示的动画速度。然后我们调用<code>ReadHeirarchyData</code>，它复制Assimp的<code>aiNode</code>继承权并创建<code>AssimpNodeData</code>的继承权。</p>
<p>然后我们调用一个名为<code>ReadMissingBones</code>的函数。我不得不编写这个函数，因为有时当我单独加载FBX模型时，它缺少一些骨骼，而我在动画文件中找到了这些缺失的骨骼。此函数读取丢失的骨骼信息，并将其信息存储在模型的<code>m_BoneInfoMap</code>中，并在<code>m_BoneIInfoMap</code>中本地保存<code>m_BoneIinfoMap</code>的引用。</p>
<p>我们已经准备好了动画。现在让我们看看我们的最后阶段，Animator类：</p>
<pre><code class="language-c++">class Animator
{   
public:
    Animator::Animator(Animation* Animation)
    {
        m_CurrentTime = 0.0;
        m_CurrentAnimation = currentAnimation;

        m_FinalBoneMatrices.reserve(100);

        for (int i = 0; i &lt; 100; i++)
            m_FinalBoneMatrices.push_back(glm::mat4(1.0f));
    }

    void Animator::UpdateAnimation(float dt)
    {
        m_DeltaTime = dt;
        if (m_CurrentAnimation)
        {
            m_CurrentTime += m_CurrentAnimation-&gt;GetTicksPerSecond() * dt;
            m_CurrentTime = fmod(m_CurrentTime, m_CurrentAnimation-&gt;GetDuration());
            CalculateBoneTransform(&amp;m_CurrentAnimation-&gt;GetRootNode(), glm::mat4(1.0f));
        }
    }

    void Animator::PlayAnimation(Animation* pAnimation)
    {
        m_CurrentAnimation = pAnimation;
        m_CurrentTime = 0.0f;
    }

    void Animator::CalculateBoneTransform(const AssimpNodeData* node, glm::mat4 parentTransform)
    {
        std::string nodeName = node-&gt;name;
        glm::mat4 nodeTransform = node-&gt;transformation;

        Bone* Bone = m_CurrentAnimation-&gt;FindBone(nodeName);

        if (Bone)
        {
            Bone-&gt;Update(m_CurrentTime);
            nodeTransform = Bone-&gt;GetLocalTransform();
        }

        glm::mat4 globalTransformation = parentTransform * nodeTransform;

        auto boneInfoMap = m_CurrentAnimation-&gt;GetBoneIDMap();
        if (boneInfoMap.find(nodeName) != boneInfoMap.end())
        {
            int index = boneInfoMap[nodeName].id;
            glm::mat4 offset = boneInfoMap[nodeName].offset;
            m_FinalBoneMatrices[index] = globalTransformation * offset;
        }

        for (int i = 0; i &lt; node-&gt;childrenCount; i++)
            CalculateBoneTransform(&amp;node-&gt;children[i], globalTransformation);
    }

    std::vector&lt;glm::mat4&gt; GetFinalBoneMatrices() 
    { 
        return m_FinalBoneMatrices;  
    }

private:
    std::vector&lt;glm::mat4&gt; m_FinalBoneMatrices;
    Animation* m_CurrentAnimation;
    float m_CurrentTime;
    float m_DeltaTime;  
};
</code></pre>
<p><code>Animator</code>构造函数将播放动画，然后继续将动画时间<code>m_CurrentTime</code>重置为0。它还初始化<code>m_FinalBoneMatrices</code>，这是一个<code>std::vector\&lt;glm::mat4\&gt;</code>。这里的主要注意点是<code>UpdateAnimation(float deltaTime)</code>函数。它以<code>m_TicksPerSecond</code>的速率推进<code>m_CurrentTime</code>，然后调用<code>CalculateBoneTransform</code>函数。我们将在开始时传递两个参数，第一个是<code>m_CurrentAnimation</code>的<code>m_RootNode</code>，第二个是作为<code>parentTransform</code>传递的身份矩阵。然后，通过在<code>animation</code>的<code>m_Bones</code>数组中查找<code>m_RootNodes</code>骨骼来检查该骨骼是否参与该动画。如果找到骨骼，则调用<code>bone.Update()</code>函数，该函数对所有骨骼进行插值，并将局部骨骼变换矩阵返回到<code>nodeTransform</code>。但这是局部空间矩阵，如果在着色器中传递，将围绕原点移动骨骼。因此，我们将这个<code>nodeTransform</code>与parentTransform相乘，并将结果存储在<code>globalTransformation</code>中。这就足够了，但顶点仍在默认模型空间中。我们在<code>m_BoneInfoMap</code>中找到偏移矩阵，然后将其与<code>globalTransfromMatrix</code>相乘。我们还将获得id索引，该索引将用于写入该骨骼到<code>m_FinalBoneMatrices</code>的最终转换。</p>
<p>最后我们为该节点的每个子节点调用<code>CalculateBoneTransform</code>，并将<code>globalTransformation</code>作为<code>parentTransform</code>传递。当没有子节点需要进一步处理时，我们会跳出这个递归循环。</p>
<h2 id="_7">让我们动起来</h2>
<p>我们辛勤工作的成果终于来了！以下是我们将如何在main.cpp中播放动画：</p>
<pre><code class="language-c++">int main()
{
    ...

    Model ourModel(FileSystem::getPath(&quot;resources/objects/vampire/dancing_vampire.dae&quot;));
    Animation danceAnimation(FileSystem::getPath(&quot;resources/objects/vampire/dancing_vampire.dae&quot;),
        &amp;ourModel);
    Animator animator(&amp;danceAnimation);

    // draw in wireframe
    //glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

    // render loop
    // -----------
    while (!glfwWindowShouldClose(window))
    {
        // per-frame time logic
        // --------------------
        float currentFrame = glfwGetTime();
        deltaTime = currentFrame - lastFrame;
        lastFrame = currentFrame;

        // input
        // -----
        processInput(window);
        animator.UpdateAnimation(deltaTime);

        // render
        // ------
        glClearColor(0.05f, 0.05f, 0.05f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        // don't forget to enable shader before setting uniforms
        ourShader.use();

        // view/projection transformations
        glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), 
            (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);
        glm::mat4 view = camera.GetViewMatrix();
        ourShader.setMat4(&quot;projection&quot;, projection);
        ourShader.setMat4(&quot;view&quot;, view);

        auto transforms = animator.GetFinalBoneMatrices();
        for (int i = 0; i &lt; transforms.size(); ++i)
            ourShader.setMat4(&quot;finalBonesMatrices[&quot; + std::to_string(i) + &quot;]&quot;, transforms[i]);

        // render the loaded model
        glm::mat4 model = glm::mat4(1.0f);
        // translate it down so it's at the center of the scene
        model = glm::translate(model, glm::vec3(0.0f, -0.4f, 0.0f)); 
        // it's a bit too big for our scene, so scale it down
        model = glm::scale(model, glm::vec3(.5f, .5f, .5f));    
        ourShader.setMat4(&quot;model&quot;, model);
        ourModel.Draw(ourShader);

        // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)
        // -------------------------------------------------------------------------------
        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    // glfw: terminate, clearing all previously allocated GLFW resources.
    // ------------------------------------------------------------------
    glfwTerminate();
    return 0;
</code></pre>
<p>我们从加载模型开始，该模型将为着色器设置骨骼重量数据，然后通过为其提供路径来创建动画。然后，我们通过将创建的<code>Animation</code>传递给它来创建<code>Animator</code>对象。在渲染循环中，我们更新<code>Animator</code>，进行最终的骨骼变换并将其提供给着色器。这是我们一直在等待的输出:</p>
<p><img alt="output" src="../../../img/08/01/output.gif" /></p>
<p>从<a href="https://learnopengl.com/Model-Loading/Assimp">此处</a>下载使用的模型。请注意，动画和网格是在单个DAE(collada)文件中烘焙的。你可以在<a href="https://learnopengl.com/code_viewer_gh.php?code=src/8.guest/2020/skeletal_animation/skeletal_animation.cpp">这里</a>找到这个演示的完整源代码。</p>
<h2 id="_8">延伸阅读</h2>
<p><a href="http://www.songho.ca/math/quaternion/quaternion.html">Quaternions</a>: An article by songho to understand quaternions in depth.
<a href="http://ogldev.atspace.co.uk/www/tutorial38/tutorial38.html">Skeletal Animation with Assimp</a>: An article by OGL Dev.
<a href="https://youtu.be/f3Cr8Yx3GGA">Skeletal Animation with Java</a>: A fantastic youtube playlist by Thin Matrix.
<a href="https://www.gamasutra.com/view/feature/131686/rotating_objects_using_quaternions.php">Why Quaternions should be used for Rotation</a>: An awesome gamasutra article.</p>

<div id="disqus_thread"></div>
<script>
    (function() {
        var d = document, s = d.createElement('script');

        s.src = '//learnopengl-cn.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>请启用JavaScript以浏览<a href="https://disqus.com/?ref_noscript" rel="nofollow">Disqus评论。</a></noscript></div>
        </div>

        <footer class="col-md-12">
            <hr>
            
            <center>Powered by <a href="http://www.mkdocs.org/">MkDocs</a> and <a href="http://bootswatch.com/yeti/">Yeti</a></center>
        </footer>

        <script src="../../../js/jquery-1.10.2.min.js"></script>
        <script src="../../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../../js/highlight.pack.js"></script>
        <script>var base_url = '../../..';</script>
        <script src="../../../js/base.js"></script>
        <script src="../../../mathjax/MathJax.js?config=TeX-AMS_HTML"></script>
        <script src="../../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">关闭</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">搜索</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            请在下面输入你要搜索的文本（仅支持英文）：
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="搜索..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>
    </body>
</html>